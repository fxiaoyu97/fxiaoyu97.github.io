# synchronized实现原理

在**JDK6**之前，`synchronized`都是重量级锁，也就是通过操作系统加锁，这时候可能会导致加锁花费的系统时间比加锁以外需要使用的时间还要多，性能偏低。从**JDK6**开始，开始进行大量优化，引入偏向锁，自选锁，轻量级锁等，性能得到很大的提升。

在HotSpot的实现中，当线程第一访问对象时，会被对象头中的MarkWord中记录下线程的ID，当线程再次访问同步代码块时，发现其中记录的是自己的线程ID，那么可以直接进入同步代码块，这里也是偏向锁。

当有其他线程来竞争资源时，那么锁就要升级为轻量级锁，当有线程在执行同步代码块时，后来的线程并不会进入等待队列，而是不断的尝试获取锁，这就是自选锁，自己不断的旋转转圈，这里要消耗CPU资源的。

如果尝试10次之后还没有获取执行同步代码块的机会，那么这时候就需要升级为重量级锁，也就是通过操作系统上锁，这时候所有尝试获取锁的线程都变为阻塞状态，也会释放CPU资源。

> 这里也能获得一些其他结论:
>
> 同步代码执行时间短，线程数少的时候，可以考虑使用自选锁，减少使用重量级锁带来的时间消耗。当同步代码执行时间长，线程数多的时候，可以考虑使用重量级锁，减少CPU资源的消耗。