<template><h1 id="设计模式之间的结合-例如策略模式-简单工厂模式的实践" tabindex="-1"><a class="header-anchor" href="#设计模式之间的结合-例如策略模式-简单工厂模式的实践" aria-hidden="true">#</a> 设计模式之间的结合，例如策略模式 + 简单工厂模式的实践</h1>
<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2>
<p>简单工厂模式和策略模式是大部分程序员，在学习设计模式时接触得最早，或在工作实践中也是用得相对比较多的两个设计模式。</p>
<p>一个是创建型，另一个是行为型，然而两种不同类型的模式，在某些地方也有一丝的相似之处，同时在某种场景下结合使用，能起到特别好的效果。</p>
<p><img src="@source/面试宝典/13.设计模式/img/488722-20150831153957044-1540181232.jpeg" alt="img"></p>
<p><img src="@source/面试宝典/13.设计模式/img/488722-20150831154009669-2101558257.jpeg" alt="img"></p>
<h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h2>
<p>简单工厂模式和策略模式很相似。怎么相似？都是三个业务子类继承抽象父类，通过传入参数到容器类（工厂模式的 factory 类，策略模式的 Content 类），选择对应的类进行行为操作。</p>
<p>其实，UML 图的确从外形上看没多大区别，但是，本质却是大大不同。</p>
<h2 id="简单工厂模式" tabindex="-1"><a class="header-anchor" href="#简单工厂模式" aria-hidden="true">#</a> 简单工厂模式</h2>
<p>上面提到过，简单工厂模式是创建型模式，创建型模式顾名思义，也就是说在创建对象的时候，遇到了瓶颈才会选择的设计模式。那么该什么情况使用呢。</p>
<p>简单工厂模式的实质是由一个工厂类根据传入的参数，<strong>动态决定</strong>应该<strong>创建并且返回</strong>哪一个产品类（这些产品类继承自一个父类或接口）的实例。</p>
<p>那么也就是说：</p>
<ul>
<li>有已知的产品类</li>
<li>你无法准确的知道编译哪个产品类</li>
<li>需要在运行时决定创建哪个产品类</li>
<li>产品类不多</li>
</ul>
<p>很明显看出，在创建对象上的灵活性高，但是工厂类只能创建可能会使用到的产品类，假如新添了产品类就得修改工厂类，这样就会违反开闭原则。</p>
<h2 id="策略模式" tabindex="-1"><a class="header-anchor" href="#策略模式" aria-hidden="true">#</a> 策略模式</h2>
<p>策略模式是行为型模式，它定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>
<p>在一段代码里，使用了逻辑控制（if-else, swich-case）来决定算法，算法有相似的方法和函数，就可以选择策略模式。</p>
<p>那么也就是说：</p>
<ul>
<li>某方法里有多个条件语句，条件语句代码块里有许多行为过程。</li>
<li>其算法能封装到策略类</li>
<li>算法随意切换</li>
<li>算法与客户端隔离</li>
</ul>
<p>这样一来，通过选择对应的策略类，作为参数传到 Content 类里，在<strong>运行时</strong>配置对应的算法。</p>
<h2 id="区别总结" tabindex="-1"><a class="header-anchor" href="#区别总结" aria-hidden="true">#</a> 区别总结</h2>
<p>从上面的描述总结出，在运行时，两者都是通过传入参数进行配置，简单工厂模式则是选择创建出需要的对象，而策略模式则是配置出需要的行为算法。一个是对象创建，另一个是行为算法的替换。</p>
</template>
