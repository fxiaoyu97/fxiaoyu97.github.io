<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.51">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/img/geass-bg.ico"><title>说说常用开源框架中设计模式使用分析 | 三更编程</title><meta name="description" content="三更编程，洛小豆">
    <link rel="modulepreload" href="/assets/app.f0c02a19.js"><link rel="modulepreload" href="/assets/说说常用开源框架中设计模式使用分析.html.59e887da.js"><link rel="modulepreload" href="/assets/说说常用开源框架中设计模式使用分析.html.cdcef30b.js"><link rel="prefetch" href="/assets/index.html.a60a18d0.js"><link rel="prefetch" href="/assets/index.html.1635f674.js"><link rel="prefetch" href="/assets/index.html.3c8e0463.js"><link rel="prefetch" href="/assets/index.html.3ce8115c.js"><link rel="prefetch" href="/assets/01.什么是Maven.html.f4afddde.js"><link rel="prefetch" href="/assets/02.POM文件.html.e1d56135.js"><link rel="prefetch" href="/assets/03.常用命令.html.89abdd1b.js"><link rel="prefetch" href="/assets/04.插件.html.5d4e6048.js"><link rel="prefetch" href="/assets/index.html.145b7920.js"><link rel="prefetch" href="/assets/1.Spring家族介绍与开发环境.html.09e0e435.js"><link rel="prefetch" href="/assets/2.Spring IoC.html.078d6b46.js"><link rel="prefetch" href="/assets/index.html.b3e6700f.js"><link rel="prefetch" href="/assets/03.Git基础配置.html.4d103e49.js"><link rel="prefetch" href="/assets/04.Git添加、重命名、删除文件.html.aed104d4.js"><link rel="prefetch" href="/assets/05.Git查询提交日志.html.7cb3e167.js"><link rel="prefetch" href="/assets/20.git推送遇到冲突时该怎么办.html.f1cbac1b.js"><link rel="prefetch" href="/assets/21.不同的人修改同一分支不同的文件.html.f3ad1278.js"><link rel="prefetch" href="/assets/22.不同的人修改同一分支相同的文件的不同区域.html.18bc1106.js"><link rel="prefetch" href="/assets/30.Git如何管理文件版本.html.e63ae30a.js"><link rel="prefetch" href="/assets/index.html.777076a3.js"><link rel="prefetch" href="/assets/index.html.8a70862a.js"><link rel="prefetch" href="/assets/index.html.3e253c62.js"><link rel="prefetch" href="/assets/index.html.015da34d.js"><link rel="prefetch" href="/assets/index.html.08414d0b.js"><link rel="prefetch" href="/assets/map、string、json互转.html.36ab0582.js"><link rel="prefetch" href="/assets/nginx屏蔽指定IP.html.09c66230.js"><link rel="prefetch" href="/assets/如何优雅的读取yml配置文件.html.fc835ad1.js"><link rel="prefetch" href="/assets/Windows中杀死占用某个端口的进程.html.42f8f77b.js"><link rel="prefetch" href="/assets/idea快捷键.html.64d984d0.js"><link rel="prefetch" href="/assets/window下nginx的启动和关闭.html.66867b21.js"><link rel="prefetch" href="/assets/01.线程的生命周期以及状态转换.html.cd7207bf.js"><link rel="prefetch" href="/assets/02.Java线程的常用方法.html.430dd19b.js"><link rel="prefetch" href="/assets/11.synchronized实现原理.html.4378f1ad.js"><link rel="prefetch" href="/assets/12.synchronized常见加锁误区.html.68cd9990.js"><link rel="prefetch" href="/assets/01.常量和变量.html.054e2d44.js"><link rel="prefetch" href="/assets/02.ASCII码和Unicode编码.html.58df254f.js"><link rel="prefetch" href="/assets/03.类型转换.html.a9913d7e.js"><link rel="prefetch" href="/assets/04.运算符.html.5ffaea42.js"><link rel="prefetch" href="/assets/05.选择结构.html.dbadcb1f.js"><link rel="prefetch" href="/assets/01.网页创建与浏览.html.db2a3331.js"><link rel="prefetch" href="/assets/02.基础标签学习.html.e754c1fc.js"><link rel="prefetch" href="/assets/05.HTML5特性.html.21a1b009.js"><link rel="prefetch" href="/assets/07.列表标签.html.58d155e6.js"><link rel="prefetch" href="/assets/08.多媒体与语义化标签.html.0e7e1c29.js"><link rel="prefetch" href="/assets/99.项目起步.html.9837b61d.js"><link rel="prefetch" href="/assets/00.JDK8新特性.html.f6c24bdb.js"><link rel="prefetch" href="/assets/01.面向对象的特征.html.6935663f.js"><link rel="prefetch" href="/assets/02.抽象类和接口有什么区别.html.4cfec85e.js"><link rel="prefetch" href="/assets/11.HTTP请求的GET与POST方式的区别.html.61e8ab6d.js"><link rel="prefetch" href="/assets/20.session与cookie区别.html.8f0bfd36.js"><link rel="prefetch" href="/assets/21.session分布式处理.html.f002b894.js"><link rel="prefetch" href="/assets/3.重载和重写的区别.html.1b3caa7a.js"><link rel="prefetch" href="/assets/30.说说反射的用途及实现.html.bf5ae492.js"><link rel="prefetch" href="/assets/31.说说自定义注解的场景及实现.html.cdc1dfe1.js"><link rel="prefetch" href="/assets/4.int和Integer有什么区别.html.58ff4cf4.js"><link rel="prefetch" href="/assets/5.equals与__的区别.html.09493dd6.js"><link rel="prefetch" href="/assets/7.final_finally_finalize的区别.html.aef31bdc.js"><link rel="prefetch" href="/assets/9.JDBC流程.html.2b579e62.js"><link rel="prefetch" href="/assets/1.ArrayList与LinkedList区别.html.23d97f28.js"><link rel="prefetch" href="/assets/11.HashMap的工作原理及代码实现.html.ceee434f.js"><link rel="prefetch" href="/assets/12.HashSet和HashMap区别.html.b1f82903.js"><link rel="prefetch" href="/assets/13.HashMap和HashTable的区别.html.e933f444.js"><link rel="prefetch" href="/assets/14.HashMap和ConcurrentHashMap的区别.html.d60fb645.js"><link rel="prefetch" href="/assets/15.ConcurrentHashMap的工作原理及代码实现.html.1a75571c.js"><link rel="prefetch" href="/assets/2.ArrayList与Vector区别.html.b05b381c.js"><link rel="prefetch" href="/assets/5.List和Map区别.html.6af95610.js"><link rel="prefetch" href="/assets/6.List和Set区别.html.306906a1.js"><link rel="prefetch" href="/assets/1.创建线程的方式及实现.html.c2c83a61.js"><link rel="prefetch" href="/assets/2.线程的生命周期.html.07ca37e0.js"><link rel="prefetch" href="/assets/21.讲讲线程池的实现原理.html.900f6229.js"><link rel="prefetch" href="/assets/22.线程池的几种方式与使用场景.html.2561260f.js"><link rel="prefetch" href="/assets/3.sleep()、join（）、yield（）有什么区别.html.67e6174d.js"><link rel="prefetch" href="/assets/31.ThreadLocal原理分析.html.115948e2.js"><link rel="prefetch" href="/assets/32.说说CountDownLatch原理.html.8de4ff99.js"><link rel="prefetch" href="/assets/33.说说CyclicBarrier原理.html.acc2b0c9.js"><link rel="prefetch" href="/assets/34.说说CountDownLatch与CyclicBarrier区别.html.b0f76a65.js"><link rel="prefetch" href="/assets/35.说说Exchanger原理.html.9c470165.js"><link rel="prefetch" href="/assets/37.说说Semaphore原理.html.c8409296.js"><link rel="prefetch" href="/assets/01.说说线程安全问题.html.040964c7.js"><link rel="prefetch" href="/assets/02.synchronize 实现原理.html.bf6f6aa4.js"><link rel="prefetch" href="/assets/03.synchronized 与 lock 的区别.html.6250e173.js"><link rel="prefetch" href="/assets/04.CAS 乐观锁.html.c1ff9d54.js"><link rel="prefetch" href="/assets/05.ABA 问题.html.b075bd88.js"><link rel="prefetch" href="/assets/06.乐观锁的业务场景及实现方式.html.3dd07b37.js"><link rel="prefetch" href="/assets/07.volatile 实现原理.html.d2e955d0.js"><link rel="prefetch" href="/assets/BeanFactory 和 ApplicationContext 有什么区别.html.51211fdc.js"><link rel="prefetch" href="/assets/Spring AOP 实现原理.html.61a35843.js"><link rel="prefetch" href="/assets/Spring Bean 的生命周期.html.b0897040.js"><link rel="prefetch" href="/assets/Spring IOC 如何实现.html.b6295edd.js"><link rel="prefetch" href="/assets/Spring MVC 启动流程.html.06e49e78.js"><link rel="prefetch" href="/assets/Spring MVC 运行流程.html.1f8140e7.js"><link rel="prefetch" href="/assets/Spring 事务实现方式.html.37c13a42.js"><link rel="prefetch" href="/assets/Spring 事务底层原理.html.a0078069.js"><link rel="prefetch" href="/assets/Spring 框架中用到了哪些设计模式.html.7e9235a1.js"><link rel="prefetch" href="/assets/Spring 的单例实现原理.html.8dcc0e01.js"><link rel="prefetch" href="/assets/动态代理（CGLIB 与 JDK）.html.ae96aba1.js"><link rel="prefetch" href="/assets/如何自定义注解实现功能.html.4d45257d.js"><link rel="prefetch" href="/assets/说说 Spring AOP.html.043bb81c.js"><link rel="prefetch" href="/assets/Session 分布式方案.html.eee2c492.js"><link rel="prefetch" href="/assets/分布式事务.html.eb71c4eb.js"><link rel="prefetch" href="/assets/分布式锁的场景与实现.html.8fdf17fe.js"><link rel="prefetch" href="/assets/谈谈业务中使用分布式的场景.html.00c3c238.js"><link rel="prefetch" href="/assets/集群与负载均衡的算法与实现.html.d21e8d01.js"><link rel="prefetch" href="/assets/你怎么理解 RESTful.html.938af527.js"><link rel="prefetch" href="/assets/你怎么理解 RPC 框架.html.a7fb1874.js"><link rel="prefetch" href="/assets/前后端分离是如何做的.html.9d9f5aca.js"><link rel="prefetch" href="/assets/如何保证接口的幂等性.html.53bf9975.js"><link rel="prefetch" href="/assets/如何应对微服务的链式调用异常.html.1130ca3d.js"><link rel="prefetch" href="/assets/如何拆分服务.html.4144bb9e.js"><link rel="prefetch" href="/assets/如何理解 RESTful API 的幂等性.html.8c5aa599.js"><link rel="prefetch" href="/assets/如何解决跨域.html.0673ef6a.js"><link rel="prefetch" href="/assets/对于快速追踪与定位问题.html.8a9b7aa7.js"><link rel="prefetch" href="/assets/微服务与 SOA 的区别.html.8e2674b3.js"><link rel="prefetch" href="/assets/微服务哪些框架.html.4794b9a1.js"><link rel="prefetch" href="/assets/微服务如何进行数据库管理.html.2c5c4f2e.js"><link rel="prefetch" href="/assets/微服务的安全.html.0c7b5dde.js"><link rel="prefetch" href="/assets/怎么考虑数据一致性问题.html.595cd3cc.js"><link rel="prefetch" href="/assets/说说 CAP 定理、 BASE 理论.html.acf21862.js"><link rel="prefetch" href="/assets/说说 Dubbo 的实现原理.html.dc1bb9d8.js"><link rel="prefetch" href="/assets/说说 RPC 的实现原理.html.a0675460.js"><link rel="prefetch" href="/assets/说说如何设计一个良好的 API.html.31ad3bf9.js"><link rel="prefetch" href="/assets/说说最终一致性的实现方案.html.0f024117.js"><link rel="prefetch" href="/assets/58 到家 MySQL 军规升级版.html.55e70374.js"><link rel="prefetch" href="/assets/MySQL 索引使用的注意事项.html.73dfb299.js"><link rel="prefetch" href="/assets/MySQL 遇到的死锁问题.html.81e52b36.js"><link rel="prefetch" href="/assets/ObjectId 规则.html.61c32567.js"><link rel="prefetch" href="/assets/limit 20000 加载很慢怎么解决.html.ae820a98.js"><link rel="prefetch" href="/assets/为什么要用 B-Tree.html.7c1cf9b8.js"><link rel="prefetch" href="/assets/倒排索引.html.8accb770.js"><link rel="prefetch" href="/assets/分库与分表带来的分布式困境与应对之策.html.306107c1.js"><link rel="prefetch" href="/assets/存储引擎的 InnoDB 与 MyiSAM.html.86025250.js"><link rel="prefetch" href="/assets/数据库索引的原理.html.8ab4b305.js"><link rel="prefetch" href="/assets/聊聊 ElasticSearch 使用场景.html.174dc643.js"><link rel="prefetch" href="/assets/聊聊 MongoDB 使用场景.html.05f58581.js"><link rel="prefetch" href="/assets/聚集索引与非聚集索引的区别.html.ac8cff2b.js"><link rel="prefetch" href="/assets/说说 SQL 优化之道.html.c20502ab.js"><link rel="prefetch" href="/assets/说说分库与分表设计.html.60ae2d38.js"><link rel="prefetch" href="/assets/说说反模式设计.html.42686146.js"><link rel="prefetch" href="/assets/选择合适的分布式主键方案.html.6debaa64.js"><link rel="prefetch" href="/assets/选择合适的数据存储方案.html.a73654cd.js"><link rel="prefetch" href="/assets/Redis 为什么是单线程的.html.93edfd65.js"><link rel="prefetch" href="/assets/Redis 内存淘汰机制.html.123afaab.js"><link rel="prefetch" href="/assets/Redis 内部结构.html.6e437c65.js"><link rel="prefetch" href="/assets/Redis 持久化机制.html.2ba41ba8.js"><link rel="prefetch" href="/assets/Redis 有哪些类型.html.7cc04f16.js"><link rel="prefetch" href="/assets/Redis 集群方案与实现.html.a0f83217.js"><link rel="prefetch" href="/assets/使用缓存的合理性问题.html.7d70513e.js"><link rel="prefetch" href="/assets/缓存崩溃.html.b109fa6b.js"><link rel="prefetch" href="/assets/缓存降级.html.25beb07c.js"><link rel="prefetch" href="/assets/聊聊 Redis 使用场景.html.030edb43.js"><link rel="prefetch" href="/assets/如何保证消息的有序性.html.dd8ddf63.js"><link rel="prefetch" href="/assets/消息的堆积解决思路.html.ce5d54fd.js"><link rel="prefetch" href="/assets/消息的幂等性解决思路.html.2265070b.js"><link rel="prefetch" href="/assets/消息的重发补偿解决思路.html.c05b5b92.js"><link rel="prefetch" href="/assets/消息队列的使用场景.html.0cad629e.js"><link rel="prefetch" href="/assets/自己如何实现消息队列.html.103d1072.js"><link rel="prefetch" href="/assets/Netty 内部执行流程.html.b55b7360.js"><link rel="prefetch" href="/assets/Netty 线程模型.html.112706cf.js"><link rel="prefetch" href="/assets/Netty 重连实现.html.74a644f3.js"><link rel="prefetch" href="/assets/TCP 粘包拆包的解决办法.html.c732fbe8.js"><link rel="prefetch" href="/assets/为什么选择 Netty.html.f1d4eeb2.js"><link rel="prefetch" href="/assets/什么是 TCP 粘包拆包.html.bbf5fd9e.js"><link rel="prefetch" href="/assets/原生的 NIO 在 JDK 1.7 版本存在 EPoll BUG.html.2daacb12.js"><link rel="prefetch" href="/assets/说说 Netty 的零拷贝.html.f13faf80.js"><link rel="prefetch" href="/assets/说说业务中 Netty 的使用场景.html.f9b0c093.js"><link rel="prefetch" href="/assets/HTTPS 原理剖析.html.1270b738.js"><link rel="prefetch" href="/assets/HTTPS 降级攻击.html.a3552431.js"><link rel="prefetch" href="/assets/基于角色的访问控制.html.04be67ef.js"><link rel="prefetch" href="/assets/安全要素与 STRIDE 威胁.html.a8396b14.js"><link rel="prefetch" href="/assets/授权与认证.html.381eefcd.js"><link rel="prefetch" href="/assets/防范常见的 Web 攻击.html.0e80498e.js"><link rel="prefetch" href="/assets/如何发现性能瓶颈.html.7bd05a81.js"><link rel="prefetch" href="/assets/性能指标有哪些.html.50aab2e3.js"><link rel="prefetch" href="/assets/性能调优的常见手段.html.4af1f1e1.js"><link rel="prefetch" href="/assets/23 种设计模式的设计理念.html.170af17c.js"><link rel="prefetch" href="/assets/设计模式之间的异同，例如策略模式与状态模式的区别.html.30fbbfd8.js"><link rel="prefetch" href="/assets/设计模式之间的结合，例如策略模式 _ 简单工厂模式的实践.html.2e40af70.js"><link rel="prefetch" href="/assets/设计模式的性能，例如单例模式哪种性能更好.html.9f3b73a7.js"><link rel="prefetch" href="/assets/说说你对设计原则的理解.html.a5def6a5.js"><link rel="prefetch" href="/assets/你如何对需求原型进行理解和拆分.html.5cfd8da1.js"><link rel="prefetch" href="/assets/你针对产品提出哪些交互和改进意见.html.96b66966.js"><link rel="prefetch" href="/assets/说说你对功能性需求的理解.html.fffd5499.js"><link rel="prefetch" href="/assets/说说你对非功能性需求的理解.html.d1e86b2d.js"><link rel="prefetch" href="/assets/你如何划分领域边界.html.36ce4599.js"><link rel="prefetch" href="/assets/你如何考虑服务化.html.7eff5b7d.js"><link rel="prefetch" href="/assets/你如何考虑组件化.html.75fbb05c.js"><link rel="prefetch" href="/assets/你如何进行领域建模.html.8505dc8f.js"><link rel="prefetch" href="/assets/说说你在项目中使用过的 UML 图.html.df1f8f43.js"><link rel="prefetch" href="/assets/说说概要设计.html.fb304301.js"><link rel="prefetch" href="/assets/JavaScript this 关键字.html.d5574058.js"><link rel="prefetch" href="/assets/MySQL 优化.html.e90618d7.js"><link rel="prefetch" href="/assets/Zookeeper 假死脑裂.html.8ed2c3eb.js"><link rel="prefetch" href="/assets/双亲委派模型.html.be6385ca.js"><link rel="prefetch" href="/assets/死信、延迟、重试队列.html.a2f30cf9.js"><link rel="prefetch" href="/assets/面试题补充.html.e25da06f.js"><link rel="prefetch" href="/assets/1.创建项目.html.f87dda77.js"><link rel="prefetch" href="/assets/2.图标组件.html.96a9149e.js"><link rel="prefetch" href="/assets/3.伸缩菜单栏.html.9c081678.js"><link rel="prefetch" href="/assets/index.html.7e8a6f84.js"><link rel="prefetch" href="/assets/1.vite.config.ts格式化失败.html.93a5099c.js"><link rel="prefetch" href="/assets/404.html.c3e557d0.js"><link rel="prefetch" href="/assets/index.html.5566acf3.js"><link rel="prefetch" href="/assets/index.html.4a0a94d6.js"><link rel="prefetch" href="/assets/index.html.61c7226a.js"><link rel="prefetch" href="/assets/index.html.de8775dc.js"><link rel="prefetch" href="/assets/01.什么是Maven.html.0a62bdb3.js"><link rel="prefetch" href="/assets/02.POM文件.html.b70231f7.js"><link rel="prefetch" href="/assets/03.常用命令.html.bab7926c.js"><link rel="prefetch" href="/assets/04.插件.html.57b62c1e.js"><link rel="prefetch" href="/assets/index.html.0c9778f9.js"><link rel="prefetch" href="/assets/1.Spring家族介绍与开发环境.html.768bdbde.js"><link rel="prefetch" href="/assets/2.Spring IoC.html.655b77cf.js"><link rel="prefetch" href="/assets/index.html.8e401a64.js"><link rel="prefetch" href="/assets/03.Git基础配置.html.a8c2dc0c.js"><link rel="prefetch" href="/assets/04.Git添加、重命名、删除文件.html.b1b91df0.js"><link rel="prefetch" href="/assets/05.Git查询提交日志.html.24ecc00c.js"><link rel="prefetch" href="/assets/20.git推送遇到冲突时该怎么办.html.6f9ac7f0.js"><link rel="prefetch" href="/assets/21.不同的人修改同一分支不同的文件.html.c6c0273a.js"><link rel="prefetch" href="/assets/22.不同的人修改同一分支相同的文件的不同区域.html.25899669.js"><link rel="prefetch" href="/assets/30.Git如何管理文件版本.html.930f7bcc.js"><link rel="prefetch" href="/assets/index.html.4ec240b2.js"><link rel="prefetch" href="/assets/index.html.c4098e2d.js"><link rel="prefetch" href="/assets/index.html.84fd0744.js"><link rel="prefetch" href="/assets/index.html.b0da3d6b.js"><link rel="prefetch" href="/assets/index.html.b0cb6455.js"><link rel="prefetch" href="/assets/map、string、json互转.html.aa7c2df8.js"><link rel="prefetch" href="/assets/nginx屏蔽指定IP.html.96d18576.js"><link rel="prefetch" href="/assets/如何优雅的读取yml配置文件.html.73334406.js"><link rel="prefetch" href="/assets/Windows中杀死占用某个端口的进程.html.43e8b717.js"><link rel="prefetch" href="/assets/idea快捷键.html.d4cfa64d.js"><link rel="prefetch" href="/assets/window下nginx的启动和关闭.html.81321b8c.js"><link rel="prefetch" href="/assets/01.线程的生命周期以及状态转换.html.c7d2d8c8.js"><link rel="prefetch" href="/assets/02.Java线程的常用方法.html.d869114b.js"><link rel="prefetch" href="/assets/11.synchronized实现原理.html.e0b05ff8.js"><link rel="prefetch" href="/assets/12.synchronized常见加锁误区.html.c98f920e.js"><link rel="prefetch" href="/assets/01.常量和变量.html.2f7052ef.js"><link rel="prefetch" href="/assets/02.ASCII码和Unicode编码.html.e258f5b7.js"><link rel="prefetch" href="/assets/03.类型转换.html.30149048.js"><link rel="prefetch" href="/assets/04.运算符.html.72e64d1b.js"><link rel="prefetch" href="/assets/05.选择结构.html.7da7aa9e.js"><link rel="prefetch" href="/assets/01.网页创建与浏览.html.edb70f1e.js"><link rel="prefetch" href="/assets/02.基础标签学习.html.81aa1e72.js"><link rel="prefetch" href="/assets/05.HTML5特性.html.c0afef35.js"><link rel="prefetch" href="/assets/07.列表标签.html.9e88c48d.js"><link rel="prefetch" href="/assets/08.多媒体与语义化标签.html.4c8ab0b2.js"><link rel="prefetch" href="/assets/99.项目起步.html.3938eab8.js"><link rel="prefetch" href="/assets/00.JDK8新特性.html.4af622d9.js"><link rel="prefetch" href="/assets/01.面向对象的特征.html.48a4299e.js"><link rel="prefetch" href="/assets/02.抽象类和接口有什么区别.html.5b11b37d.js"><link rel="prefetch" href="/assets/11.HTTP请求的GET与POST方式的区别.html.a568c588.js"><link rel="prefetch" href="/assets/20.session与cookie区别.html.411efaad.js"><link rel="prefetch" href="/assets/21.session分布式处理.html.e74facb0.js"><link rel="prefetch" href="/assets/3.重载和重写的区别.html.68290812.js"><link rel="prefetch" href="/assets/30.说说反射的用途及实现.html.d37d44b9.js"><link rel="prefetch" href="/assets/31.说说自定义注解的场景及实现.html.6255cc79.js"><link rel="prefetch" href="/assets/4.int和Integer有什么区别.html.46288c62.js"><link rel="prefetch" href="/assets/5.equals与__的区别.html.822900ed.js"><link rel="prefetch" href="/assets/7.final_finally_finalize的区别.html.1bb3df4c.js"><link rel="prefetch" href="/assets/9.JDBC流程.html.e3c20f54.js"><link rel="prefetch" href="/assets/1.ArrayList与LinkedList区别.html.d26f2711.js"><link rel="prefetch" href="/assets/11.HashMap的工作原理及代码实现.html.f62932e1.js"><link rel="prefetch" href="/assets/12.HashSet和HashMap区别.html.5042e4fd.js"><link rel="prefetch" href="/assets/13.HashMap和HashTable的区别.html.b8b8a85b.js"><link rel="prefetch" href="/assets/14.HashMap和ConcurrentHashMap的区别.html.accd6ef3.js"><link rel="prefetch" href="/assets/15.ConcurrentHashMap的工作原理及代码实现.html.e77113e5.js"><link rel="prefetch" href="/assets/2.ArrayList与Vector区别.html.5cbee604.js"><link rel="prefetch" href="/assets/5.List和Map区别.html.70ff9b67.js"><link rel="prefetch" href="/assets/6.List和Set区别.html.d3e876d5.js"><link rel="prefetch" href="/assets/1.创建线程的方式及实现.html.16bb5f2d.js"><link rel="prefetch" href="/assets/2.线程的生命周期.html.5983d9e8.js"><link rel="prefetch" href="/assets/21.讲讲线程池的实现原理.html.cd1baa02.js"><link rel="prefetch" href="/assets/22.线程池的几种方式与使用场景.html.3978a96b.js"><link rel="prefetch" href="/assets/3.sleep()、join（）、yield（）有什么区别.html.50041de4.js"><link rel="prefetch" href="/assets/31.ThreadLocal原理分析.html.eefae4da.js"><link rel="prefetch" href="/assets/32.说说CountDownLatch原理.html.6149571d.js"><link rel="prefetch" href="/assets/33.说说CyclicBarrier原理.html.699a5be3.js"><link rel="prefetch" href="/assets/34.说说CountDownLatch与CyclicBarrier区别.html.eb7ec075.js"><link rel="prefetch" href="/assets/35.说说Exchanger原理.html.13987fa4.js"><link rel="prefetch" href="/assets/37.说说Semaphore原理.html.2f27a049.js"><link rel="prefetch" href="/assets/01.说说线程安全问题.html.0419f73e.js"><link rel="prefetch" href="/assets/02.synchronize 实现原理.html.c9cf16dd.js"><link rel="prefetch" href="/assets/03.synchronized 与 lock 的区别.html.31a8ff5d.js"><link rel="prefetch" href="/assets/04.CAS 乐观锁.html.5f76bf7f.js"><link rel="prefetch" href="/assets/05.ABA 问题.html.83ae1ee2.js"><link rel="prefetch" href="/assets/06.乐观锁的业务场景及实现方式.html.528df455.js"><link rel="prefetch" href="/assets/07.volatile 实现原理.html.e7c23749.js"><link rel="prefetch" href="/assets/BeanFactory 和 ApplicationContext 有什么区别.html.29ddb962.js"><link rel="prefetch" href="/assets/Spring AOP 实现原理.html.f02a33b3.js"><link rel="prefetch" href="/assets/Spring Bean 的生命周期.html.2897ff76.js"><link rel="prefetch" href="/assets/Spring IOC 如何实现.html.7cca7d10.js"><link rel="prefetch" href="/assets/Spring MVC 启动流程.html.8b7e6c1b.js"><link rel="prefetch" href="/assets/Spring MVC 运行流程.html.f481ec61.js"><link rel="prefetch" href="/assets/Spring 事务实现方式.html.db885eaf.js"><link rel="prefetch" href="/assets/Spring 事务底层原理.html.5abfa2d8.js"><link rel="prefetch" href="/assets/Spring 框架中用到了哪些设计模式.html.319d49fe.js"><link rel="prefetch" href="/assets/Spring 的单例实现原理.html.c5225c84.js"><link rel="prefetch" href="/assets/动态代理（CGLIB 与 JDK）.html.080f3cae.js"><link rel="prefetch" href="/assets/如何自定义注解实现功能.html.564fd2da.js"><link rel="prefetch" href="/assets/说说 Spring AOP.html.32d06f04.js"><link rel="prefetch" href="/assets/Session 分布式方案.html.a95a126c.js"><link rel="prefetch" href="/assets/分布式事务.html.3f373b2d.js"><link rel="prefetch" href="/assets/分布式锁的场景与实现.html.21d9eb5f.js"><link rel="prefetch" href="/assets/谈谈业务中使用分布式的场景.html.7685c0fe.js"><link rel="prefetch" href="/assets/集群与负载均衡的算法与实现.html.98446336.js"><link rel="prefetch" href="/assets/你怎么理解 RESTful.html.9238d9ee.js"><link rel="prefetch" href="/assets/你怎么理解 RPC 框架.html.7cf41a72.js"><link rel="prefetch" href="/assets/前后端分离是如何做的.html.b169a778.js"><link rel="prefetch" href="/assets/如何保证接口的幂等性.html.ad976ee8.js"><link rel="prefetch" href="/assets/如何应对微服务的链式调用异常.html.645f7fd3.js"><link rel="prefetch" href="/assets/如何拆分服务.html.0cf0d2d8.js"><link rel="prefetch" href="/assets/如何理解 RESTful API 的幂等性.html.e7e6dd47.js"><link rel="prefetch" href="/assets/如何解决跨域.html.4d6ea2d9.js"><link rel="prefetch" href="/assets/对于快速追踪与定位问题.html.00889533.js"><link rel="prefetch" href="/assets/微服务与 SOA 的区别.html.e7728678.js"><link rel="prefetch" href="/assets/微服务哪些框架.html.3b36a0c5.js"><link rel="prefetch" href="/assets/微服务如何进行数据库管理.html.1a3b7eb6.js"><link rel="prefetch" href="/assets/微服务的安全.html.24690a06.js"><link rel="prefetch" href="/assets/怎么考虑数据一致性问题.html.0a66bba2.js"><link rel="prefetch" href="/assets/说说 CAP 定理、 BASE 理论.html.9455b593.js"><link rel="prefetch" href="/assets/说说 Dubbo 的实现原理.html.93056bb8.js"><link rel="prefetch" href="/assets/说说 RPC 的实现原理.html.83c00bff.js"><link rel="prefetch" href="/assets/说说如何设计一个良好的 API.html.f12a6041.js"><link rel="prefetch" href="/assets/说说最终一致性的实现方案.html.e136684c.js"><link rel="prefetch" href="/assets/58 到家 MySQL 军规升级版.html.97c395df.js"><link rel="prefetch" href="/assets/MySQL 索引使用的注意事项.html.6ea071b7.js"><link rel="prefetch" href="/assets/MySQL 遇到的死锁问题.html.6569eaac.js"><link rel="prefetch" href="/assets/ObjectId 规则.html.fe59e308.js"><link rel="prefetch" href="/assets/limit 20000 加载很慢怎么解决.html.900979ca.js"><link rel="prefetch" href="/assets/为什么要用 B-Tree.html.5bb61422.js"><link rel="prefetch" href="/assets/倒排索引.html.bc2f7d1b.js"><link rel="prefetch" href="/assets/分库与分表带来的分布式困境与应对之策.html.86380f37.js"><link rel="prefetch" href="/assets/存储引擎的 InnoDB 与 MyiSAM.html.17702ab4.js"><link rel="prefetch" href="/assets/数据库索引的原理.html.3ad70e78.js"><link rel="prefetch" href="/assets/聊聊 ElasticSearch 使用场景.html.34e5c560.js"><link rel="prefetch" href="/assets/聊聊 MongoDB 使用场景.html.06707710.js"><link rel="prefetch" href="/assets/聚集索引与非聚集索引的区别.html.30d94c81.js"><link rel="prefetch" href="/assets/说说 SQL 优化之道.html.eefb67fe.js"><link rel="prefetch" href="/assets/说说分库与分表设计.html.19af5fe8.js"><link rel="prefetch" href="/assets/说说反模式设计.html.429a8ce6.js"><link rel="prefetch" href="/assets/选择合适的分布式主键方案.html.67f9d369.js"><link rel="prefetch" href="/assets/选择合适的数据存储方案.html.cea05939.js"><link rel="prefetch" href="/assets/Redis 为什么是单线程的.html.90a90ac8.js"><link rel="prefetch" href="/assets/Redis 内存淘汰机制.html.7db97296.js"><link rel="prefetch" href="/assets/Redis 内部结构.html.47f7ed93.js"><link rel="prefetch" href="/assets/Redis 持久化机制.html.4bdbfc53.js"><link rel="prefetch" href="/assets/Redis 有哪些类型.html.cc87ee75.js"><link rel="prefetch" href="/assets/Redis 集群方案与实现.html.26adcccf.js"><link rel="prefetch" href="/assets/使用缓存的合理性问题.html.aa238cc6.js"><link rel="prefetch" href="/assets/缓存崩溃.html.12d4f5aa.js"><link rel="prefetch" href="/assets/缓存降级.html.5119ebf9.js"><link rel="prefetch" href="/assets/聊聊 Redis 使用场景.html.7598f569.js"><link rel="prefetch" href="/assets/如何保证消息的有序性.html.93e06c8e.js"><link rel="prefetch" href="/assets/消息的堆积解决思路.html.c5b2f90d.js"><link rel="prefetch" href="/assets/消息的幂等性解决思路.html.72efe281.js"><link rel="prefetch" href="/assets/消息的重发补偿解决思路.html.898b38ac.js"><link rel="prefetch" href="/assets/消息队列的使用场景.html.ec7b54b8.js"><link rel="prefetch" href="/assets/自己如何实现消息队列.html.bd96f10b.js"><link rel="prefetch" href="/assets/Netty 内部执行流程.html.6b5855de.js"><link rel="prefetch" href="/assets/Netty 线程模型.html.a0d3d65d.js"><link rel="prefetch" href="/assets/Netty 重连实现.html.0cc15953.js"><link rel="prefetch" href="/assets/TCP 粘包拆包的解决办法.html.dc6231fb.js"><link rel="prefetch" href="/assets/为什么选择 Netty.html.b8ab1532.js"><link rel="prefetch" href="/assets/什么是 TCP 粘包拆包.html.abc17849.js"><link rel="prefetch" href="/assets/原生的 NIO 在 JDK 1.7 版本存在 EPoll BUG.html.60f68614.js"><link rel="prefetch" href="/assets/说说 Netty 的零拷贝.html.6da6e8dd.js"><link rel="prefetch" href="/assets/说说业务中 Netty 的使用场景.html.32a1c425.js"><link rel="prefetch" href="/assets/HTTPS 原理剖析.html.f2328379.js"><link rel="prefetch" href="/assets/HTTPS 降级攻击.html.129ef0e5.js"><link rel="prefetch" href="/assets/基于角色的访问控制.html.0dc31e3b.js"><link rel="prefetch" href="/assets/安全要素与 STRIDE 威胁.html.5cfd3b08.js"><link rel="prefetch" href="/assets/授权与认证.html.ccecec7e.js"><link rel="prefetch" href="/assets/防范常见的 Web 攻击.html.0e5babe5.js"><link rel="prefetch" href="/assets/如何发现性能瓶颈.html.19ae0a35.js"><link rel="prefetch" href="/assets/性能指标有哪些.html.11411692.js"><link rel="prefetch" href="/assets/性能调优的常见手段.html.276ced96.js"><link rel="prefetch" href="/assets/23 种设计模式的设计理念.html.236e122d.js"><link rel="prefetch" href="/assets/设计模式之间的异同，例如策略模式与状态模式的区别.html.e8554fc5.js"><link rel="prefetch" href="/assets/设计模式之间的结合，例如策略模式 _ 简单工厂模式的实践.html.a7717cef.js"><link rel="prefetch" href="/assets/设计模式的性能，例如单例模式哪种性能更好.html.2a83c5dd.js"><link rel="prefetch" href="/assets/说说你对设计原则的理解.html.1f83ef33.js"><link rel="prefetch" href="/assets/你如何对需求原型进行理解和拆分.html.1e0051d7.js"><link rel="prefetch" href="/assets/你针对产品提出哪些交互和改进意见.html.66419ff7.js"><link rel="prefetch" href="/assets/说说你对功能性需求的理解.html.6a5fa173.js"><link rel="prefetch" href="/assets/说说你对非功能性需求的理解.html.798574c1.js"><link rel="prefetch" href="/assets/你如何划分领域边界.html.2d64baaf.js"><link rel="prefetch" href="/assets/你如何考虑服务化.html.6cc6f930.js"><link rel="prefetch" href="/assets/你如何考虑组件化.html.fe8eb92d.js"><link rel="prefetch" href="/assets/你如何进行领域建模.html.7c3f21fe.js"><link rel="prefetch" href="/assets/说说你在项目中使用过的 UML 图.html.64c1d3c9.js"><link rel="prefetch" href="/assets/说说概要设计.html.0f12d26f.js"><link rel="prefetch" href="/assets/JavaScript this 关键字.html.6fb3ab8c.js"><link rel="prefetch" href="/assets/MySQL 优化.html.857bc9c2.js"><link rel="prefetch" href="/assets/Zookeeper 假死脑裂.html.d0cf66bd.js"><link rel="prefetch" href="/assets/双亲委派模型.html.9620ccbe.js"><link rel="prefetch" href="/assets/死信、延迟、重试队列.html.21613a3c.js"><link rel="prefetch" href="/assets/面试题补充.html.77026891.js"><link rel="prefetch" href="/assets/1.创建项目.html.cff57c5b.js"><link rel="prefetch" href="/assets/2.图标组件.html.3e342a3c.js"><link rel="prefetch" href="/assets/3.伸缩菜单栏.html.6b5e02f2.js"><link rel="prefetch" href="/assets/index.html.65bcbba2.js"><link rel="prefetch" href="/assets/1.vite.config.ts格式化失败.html.5a938678.js"><link rel="prefetch" href="/assets/404.html.00b637b3.js">
    <link rel="stylesheet" href="/assets/style.f4d22aab.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="https://vuejs.org/images/logo.png" alt="三更编程"><span class="site-name can-hide">三更编程</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="前端"><span class="title">前端</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="前端"><span class="title">前端</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/前端工程师/" class="" aria-label="《前端工程师》"><!--[--><!--]--> 《前端工程师》 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/Java工程师/" class="" aria-label="《Java工程师》"><!--[--><!--]--> 《Java工程师》 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java基础/" class="" aria-label="Java基础"><!--[--><!--]--> Java基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Spring/" class="" aria-label="Spring"><!--[--><!--]--> Spring <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="编程工具"><span class="title">编程工具</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="编程工具"><span class="title">编程工具</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/git/" class="" aria-label="Git"><!--[--><!--]--> Git <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Maven/" class="" aria-label="Maven"><!--[--><!--]--> Maven <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a href="/算法/" class="" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="前端"><span class="title">前端</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="前端"><span class="title">前端</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/前端工程师/" class="" aria-label="《前端工程师》"><!--[--><!--]--> 《前端工程师》 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/Java工程师/" class="" aria-label="《Java工程师》"><!--[--><!--]--> 《Java工程师》 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java基础/" class="" aria-label="Java基础"><!--[--><!--]--> Java基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Spring/" class="" aria-label="Spring"><!--[--><!--]--> Spring <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="编程工具"><span class="title">编程工具</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="编程工具"><span class="title">编程工具</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/git/" class="" aria-label="Git"><!--[--><!--]--> Git <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Maven/" class="" aria-label="Maven"><!--[--><!--]--> Maven <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a href="/算法/" class="" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">java基础 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/00.java%E5%9F%BA%E7%A1%80/00.JDK8%E6%96%B0%E7%89%B9%E6%80%A7.html" class="sidebar-item" aria-label="JDK8 新特性"><!--[--><!--]--> JDK8 新特性 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/00.java%E5%9F%BA%E7%A1%80/01.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81.html" class="sidebar-item" aria-label="面向对象的特征"><!--[--><!--]--> 面向对象的特征 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/00.java%E5%9F%BA%E7%A1%80/02.%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="抽象类和接口有什么区别"><!--[--><!--]--> 抽象类和接口有什么区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/00.java%E5%9F%BA%E7%A1%80/3.%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="重载和重写的区别"><!--[--><!--]--> 重载和重写的区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/00.java%E5%9F%BA%E7%A1%80/4.int%E5%92%8CInteger%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="int 和 Integer 有什么区别"><!--[--><!--]--> int 和 Integer 有什么区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/00.java%E5%9F%BA%E7%A1%80/5.equals%E4%B8%8E==%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="equals 与 == 的区别"><!--[--><!--]--> equals 与 == 的区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/00.java%E5%9F%BA%E7%A1%80/7.final,finally,finalize%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="final, finally, finalize 的区别"><!--[--><!--]--> final, finally, finalize 的区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/00.java%E5%9F%BA%E7%A1%80/9.JDBC%E6%B5%81%E7%A8%8B.html" class="sidebar-item" aria-label="JDBC 流程"><!--[--><!--]--> JDBC 流程 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/00.java%E5%9F%BA%E7%A1%80/11.HTTP%E8%AF%B7%E6%B1%82%E7%9A%84GET%E4%B8%8EPOST%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="HTTP 请求的 GET 与 POST 方式的区别"><!--[--><!--]--> HTTP 请求的 GET 与 POST 方式的区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/00.java%E5%9F%BA%E7%A1%80/20.session%E4%B8%8Ecookie%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="session 与 cookie 区别"><!--[--><!--]--> session 与 cookie 区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/00.java%E5%9F%BA%E7%A1%80/21.session%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%84%E7%90%86.html" class="sidebar-item" aria-label="session 分布式处理"><!--[--><!--]--> session 分布式处理 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/00.java%E5%9F%BA%E7%A1%80/30.%E8%AF%B4%E8%AF%B4%E5%8F%8D%E5%B0%84%E7%9A%84%E7%94%A8%E9%80%94%E5%8F%8A%E5%AE%9E%E7%8E%B0.html" class="sidebar-item" aria-label="说说反射的用途及实现"><!--[--><!--]--> 说说反射的用途及实现 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/00.java%E5%9F%BA%E7%A1%80/31.%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0.html" class="sidebar-item" aria-label="说说自定义注解的场景及实现"><!--[--><!--]--> 说说自定义注解的场景及实现 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">java集合 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01.java%E9%9B%86%E5%90%88/1.ArrayList%E4%B8%8ELinkedList%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="ArrayList 与 LinkedList 区别"><!--[--><!--]--> ArrayList 与 LinkedList 区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01.java%E9%9B%86%E5%90%88/2.ArrayList%E4%B8%8EVector%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="ArrayList 与 Vector 区别"><!--[--><!--]--> ArrayList 与 Vector 区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01.java%E9%9B%86%E5%90%88/5.List%E5%92%8CMap%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="List 和 Map 区别"><!--[--><!--]--> List 和 Map 区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01.java%E9%9B%86%E5%90%88/6.List%E5%92%8CSet%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="List 和 Set 区别"><!--[--><!--]--> List 和 Set 区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01.java%E9%9B%86%E5%90%88/11.HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html" class="sidebar-item" aria-label="HashMap 的工作原理及代码实现"><!--[--><!--]--> HashMap 的工作原理及代码实现 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01.java%E9%9B%86%E5%90%88/12.HashSet%E5%92%8CHashMap%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="HashSet 和 HashMap 区别"><!--[--><!--]--> HashSet 和 HashMap 区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01.java%E9%9B%86%E5%90%88/13.HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="HashMap 和 HashTable 的区别"><!--[--><!--]--> HashMap 和 HashTable 的区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01.java%E9%9B%86%E5%90%88/14.HashMap%E5%92%8CConcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="HashMap 和 ConcurrentHashMap 的区别"><!--[--><!--]--> HashMap 和 ConcurrentHashMap 的区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01.java%E9%9B%86%E5%90%88/15.ConcurrentHashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html" class="sidebar-item" aria-label="ConcurrentHashMap 的工作原理及代码实现"><!--[--><!--]--> ConcurrentHashMap 的工作原理及代码实现 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">Java线程 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%E7%BA%BF%E7%A8%8B/1.%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0.html" class="sidebar-item" aria-label="创建线程的方式及实现"><!--[--><!--]--> 创建线程的方式及实现 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%E7%BA%BF%E7%A8%8B/2.%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html" class="sidebar-item" aria-label="线程的生命周期"><!--[--><!--]--> 线程的生命周期 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%E7%BA%BF%E7%A8%8B/3.sleep()%E3%80%81join%EF%BC%88%EF%BC%89%E3%80%81yield%EF%BC%88%EF%BC%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="sleep()、join（）、yield（）有什么区别"><!--[--><!--]--> sleep()、join（）、yield（）有什么区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%E7%BA%BF%E7%A8%8B/21.%E8%AE%B2%E8%AE%B2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="讲讲线程池的实现原理"><!--[--><!--]--> 讲讲线程池的实现原理 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%E7%BA%BF%E7%A8%8B/22.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html" class="sidebar-item" aria-label="线程池的几种方式与使用场景"><!--[--><!--]--> 线程池的几种方式与使用场景 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%E7%BA%BF%E7%A8%8B/31.ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html" class="sidebar-item" aria-label="ThreadLocal 原理分析"><!--[--><!--]--> ThreadLocal 原理分析 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%E7%BA%BF%E7%A8%8B/32.%E8%AF%B4%E8%AF%B4CountDownLatch%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="说说 CountDownLatch 原理"><!--[--><!--]--> 说说 CountDownLatch 原理 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%E7%BA%BF%E7%A8%8B/33.%E8%AF%B4%E8%AF%B4CyclicBarrier%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="说说 CyclicBarrier 原理"><!--[--><!--]--> 说说 CyclicBarrier 原理 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%E7%BA%BF%E7%A8%8B/34.%E8%AF%B4%E8%AF%B4CountDownLatch%E4%B8%8ECyclicBarrier%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="说说 CountDownLatch 与 CyclicBarrier 区别"><!--[--><!--]--> 说说 CountDownLatch 与 CyclicBarrier 区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%E7%BA%BF%E7%A8%8B/35.%E8%AF%B4%E8%AF%B4Exchanger%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="说说 Exchanger 原理"><!--[--><!--]--> 说说 Exchanger 原理 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%E7%BA%BF%E7%A8%8B/37.%E8%AF%B4%E8%AF%B4Semaphore%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="说说 Semaphore 原理"><!--[--><!--]--> 说说 Semaphore 原理 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">Java 锁机制 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/03.Java%20%E9%94%81%E6%9C%BA%E5%88%B6/01.%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.html" class="sidebar-item" aria-label="说说线程安全问题"><!--[--><!--]--> 说说线程安全问题 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/03.Java%20%E9%94%81%E6%9C%BA%E5%88%B6/02.synchronize%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="synchronize 实现原理"><!--[--><!--]--> synchronize 实现原理 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/03.Java%20%E9%94%81%E6%9C%BA%E5%88%B6/03.synchronized%20%E4%B8%8E%20lock%20%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="synchronized 与 lock 的区别"><!--[--><!--]--> synchronized 与 lock 的区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/03.Java%20%E9%94%81%E6%9C%BA%E5%88%B6/04.CAS%20%E4%B9%90%E8%A7%82%E9%94%81.html" class="sidebar-item" aria-label="CAS 乐观锁"><!--[--><!--]--> CAS 乐观锁 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/03.Java%20%E9%94%81%E6%9C%BA%E5%88%B6/05.ABA%20%E9%97%AE%E9%A2%98.html" class="sidebar-item" aria-label="ABA问题"><!--[--><!--]--> ABA问题 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/03.Java%20%E9%94%81%E6%9C%BA%E5%88%B6/06.%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html" class="sidebar-item" aria-label="乐观锁的业务场景及实现方式"><!--[--><!--]--> 乐观锁的业务场景及实现方式 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/03.Java%20%E9%94%81%E6%9C%BA%E5%88%B6/07.volatile%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="volatile 实现原理"><!--[--><!--]--> volatile 实现原理 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">Spring <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.Spring/BeanFactory%20%E5%92%8C%20ApplicationContext%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="BeanFactory 和 ApplicationContext 有什么区别"><!--[--><!--]--> BeanFactory 和 ApplicationContext 有什么区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.Spring/Spring%20AOP%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="Spring AOP 实现原理"><!--[--><!--]--> Spring AOP 实现原理 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.Spring/Spring%20Bean%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html" class="sidebar-item" aria-label="Spring Bean 的生命周期"><!--[--><!--]--> Spring Bean 的生命周期 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.Spring/Spring%20IOC%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0.html" class="sidebar-item" aria-label="Spring IOC 如何实现"><!--[--><!--]--> Spring IOC 如何实现 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.Spring/Spring%20MVC%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html" class="sidebar-item" aria-label="Spring MVC 启动流程"><!--[--><!--]--> Spring MVC 启动流程 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.Spring/Spring%20MVC%20%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.html" class="sidebar-item" aria-label="Spring MVC 运行流程"><!--[--><!--]--> Spring MVC 运行流程 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.Spring/Spring%20%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html" class="sidebar-item" aria-label="Spring 事务实现方式"><!--[--><!--]--> Spring 事务实现方式 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.Spring/Spring%20%E4%BA%8B%E5%8A%A1%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="Spring 事务底层原理"><!--[--><!--]--> Spring 事务底层原理 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.Spring/Spring%20%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="sidebar-item" aria-label="Spring 框架中用到了哪些设计模式"><!--[--><!--]--> Spring 框架中用到了哪些设计模式 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.Spring/Spring%20%E7%9A%84%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="Spring 的单例实现原理"><!--[--><!--]--> Spring 的单例实现原理 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.Spring/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88CGLIB%20%E4%B8%8E%20JDK%EF%BC%89.html" class="sidebar-item" aria-label="动态代理（CGLIB 与 JDK）"><!--[--><!--]--> 动态代理（CGLIB 与 JDK） <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.Spring/%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD.html" class="sidebar-item" aria-label="如何自定义注解实现功能"><!--[--><!--]--> 如何自定义注解实现功能 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.Spring/%E8%AF%B4%E8%AF%B4%20Spring%20AOP.html" class="sidebar-item" aria-label="说说 Spring AOP"><!--[--><!--]--> 说说 Spring AOP <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">分布式 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/05.%E5%88%86%E5%B8%83%E5%BC%8F/Session%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%B9%E6%A1%88.html" class="sidebar-item" aria-label="Session 分布式方案"><!--[--><!--]--> Session 分布式方案 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/05.%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html" class="sidebar-item" aria-label="分布式事务"><!--[--><!--]--> 分布式事务 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/05.%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0.html" class="sidebar-item" aria-label="分布式锁的场景与实现"><!--[--><!--]--> 分布式锁的场景与实现 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/05.%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B0%88%E8%B0%88%E4%B8%9A%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%9C%BA%E6%99%AF.html" class="sidebar-item" aria-label="谈谈业务中使用分布式的场景"><!--[--><!--]--> 谈谈业务中使用分布式的场景 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/05.%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9B%86%E7%BE%A4%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0.html" class="sidebar-item" aria-label="集群与负载均衡的算法与实现"><!--[--><!--]--> 集群与负载均衡的算法与实现 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">微服务 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%BD%A0%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%20RESTful.html" class="sidebar-item" aria-label="你怎么理解 RESTful"><!--[--><!--]--> 你怎么理解 RESTful <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%BD%A0%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%20RPC%20%E6%A1%86%E6%9E%B6.html" class="sidebar-item" aria-label="你怎么理解 RPC 框架"><!--[--><!--]--> 你怎么理解 RPC 框架 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%9A%84.html" class="sidebar-item" aria-label="前后端分离是如何做的"><!--[--><!--]--> 前后端分离是如何做的 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7.html" class="sidebar-item" aria-label="如何保证接口的幂等性"><!--[--><!--]--> 如何保证接口的幂等性 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8.html" class="sidebar-item" aria-label="如何应对微服务的链式调用异常"><!--[--><!--]--> 如何应对微服务的链式调用异常 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E6%8B%86%E5%88%86%E6%9C%8D%E5%8A%A1.html" class="sidebar-item" aria-label="如何拆分服务"><!--[--><!--]--> 如何拆分服务 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20RESTful%20API%20%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7.html" class="sidebar-item" aria-label="如何理解 RESTful API 的幂等性"><!--[--><!--]--> 如何理解 RESTful API 的幂等性 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F.html" class="sidebar-item" aria-label="如何解决跨域"><!--[--><!--]--> 如何解决跨域 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%AF%B9%E4%BA%8E%E5%BF%AB%E9%80%9F%E8%BF%BD%E8%B8%AA%E4%B8%8E%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98.html" class="sidebar-item" aria-label="对于快速追踪与定位问题"><!--[--><!--]--> 对于快速追踪与定位问题 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%20SOA%20%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="微服务与 SOA 的区别"><!--[--><!--]--> 微服务与 SOA 的区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%93%AA%E4%BA%9B%E6%A1%86%E6%9E%B6.html" class="sidebar-item" aria-label="微服务哪些框架"><!--[--><!--]--> 微服务哪些框架 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86.html" class="sidebar-item" aria-label="微服务如何进行数据库管理"><!--[--><!--]--> 微服务如何进行数据库管理 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%89%E5%85%A8.html" class="sidebar-item" aria-label="微服务的安全"><!--[--><!--]--> 微服务的安全 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%80%8E%E4%B9%88%E8%80%83%E8%99%91%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.html" class="sidebar-item" aria-label="怎么考虑数据一致性问题"><!--[--><!--]--> 怎么考虑数据一致性问题 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%AF%B4%E8%AF%B4%20CAP%20%E5%AE%9A%E7%90%86%E3%80%81%20BASE%20%E7%90%86%E8%AE%BA.html" class="sidebar-item" aria-label="说说 CAP 定理、 BASE 理论"><!--[--><!--]--> 说说 CAP 定理、 BASE 理论 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%AF%B4%E8%AF%B4%20Dubbo%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="说说 Dubbo 的实现原理"><!--[--><!--]--> 说说 Dubbo 的实现原理 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%AF%B4%E8%AF%B4%20RPC%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="说说 RPC 的实现原理"><!--[--><!--]--> 说说 RPC 的实现原理 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E8%89%AF%E5%A5%BD%E7%9A%84%20API.html" class="sidebar-item" aria-label="说说如何设计一个良好的 API"><!--[--><!--]--> 说说如何设计一个良好的 API <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06.%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%AF%B4%E8%AF%B4%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88.html" class="sidebar-item" aria-label="说说最终一致性的实现方案"><!--[--><!--]--> 说说最终一致性的实现方案 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">数据存储 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/58%20%E5%88%B0%E5%AE%B6%20MySQL%20%E5%86%9B%E8%A7%84%E5%8D%87%E7%BA%A7%E7%89%88.html" class="sidebar-item" aria-label="58 到家 MySQL 军规升级版"><!--[--><!--]--> 58 到家 MySQL 军规升级版 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/MySQL%20%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html" class="sidebar-item" aria-label="MySQL 索引使用的注意事项"><!--[--><!--]--> MySQL 索引使用的注意事项 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/MySQL%20%E9%81%87%E5%88%B0%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98.html" class="sidebar-item" aria-label="MySQL 遇到的死锁问题"><!--[--><!--]--> MySQL 遇到的死锁问题 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/ObjectId%20%E8%A7%84%E5%88%99.html" class="sidebar-item" aria-label="ObjectId 规则"><!--[--><!--]--> ObjectId 规则 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/limit%2020000%20%E5%8A%A0%E8%BD%BD%E5%BE%88%E6%85%A2%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3.html" class="sidebar-item" aria-label="limit 20000 加载很慢怎么解决"><!--[--><!--]--> limit 20000 加载很慢怎么解决 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%20B-Tree.html" class="sidebar-item" aria-label="为什么要用 B-Tree"><!--[--><!--]--> 为什么要用 B-Tree <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.html" class="sidebar-item" aria-label="倒排索引"><!--[--><!--]--> 倒排索引 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E5%88%86%E5%BA%93%E4%B8%8E%E5%88%86%E8%A1%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%9B%B0%E5%A2%83%E4%B8%8E%E5%BA%94%E5%AF%B9%E4%B9%8B%E7%AD%96.html" class="sidebar-item" aria-label="分库与分表带来的分布式困境与应对之策"><!--[--><!--]--> 分库与分表带来的分布式困境与应对之策 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%20InnoDB%20%E4%B8%8E%20MyiSAM.html" class="sidebar-item" aria-label="存储引擎的 InnoDB 与 MyiSAM"><!--[--><!--]--> 存储引擎的 InnoDB 与 MyiSAM <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="数据库索引的原理"><!--[--><!--]--> 数据库索引的原理 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E8%81%8A%E8%81%8A%20ElasticSearch%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html" class="sidebar-item" aria-label="聊聊 ElasticSearch 使用场景"><!--[--><!--]--> 聊聊 ElasticSearch 使用场景 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E8%81%8A%E8%81%8A%20MongoDB%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html" class="sidebar-item" aria-label="聊聊 MongoDB 使用场景"><!--[--><!--]--> 聊聊 MongoDB 使用场景 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="聚集索引与非聚集索引的区别"><!--[--><!--]--> 聚集索引与非聚集索引的区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E8%AF%B4%E8%AF%B4%20SQL%20%E4%BC%98%E5%8C%96%E4%B9%8B%E9%81%93.html" class="sidebar-item" aria-label="说说 SQL 优化之道"><!--[--><!--]--> 说说 SQL 优化之道 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E8%AF%B4%E8%AF%B4%E5%88%86%E5%BA%93%E4%B8%8E%E5%88%86%E8%A1%A8%E8%AE%BE%E8%AE%A1.html" class="sidebar-item" aria-label="说说分库与分表设计"><!--[--><!--]--> 说说分库与分表设计 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E8%AF%B4%E8%AF%B4%E5%8F%8D%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1.html" class="sidebar-item" aria-label="说说反模式设计"><!--[--><!--]--> 说说反模式设计 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%BB%E9%94%AE%E6%96%B9%E6%A1%88.html" class="sidebar-item" aria-label="选择合适的分布式主键方案"><!--[--><!--]--> 选择合适的分布式主键方案 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/07.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88.html" class="sidebar-item" aria-label="选择合适的数据存储方案"><!--[--><!--]--> 选择合适的数据存储方案 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">缓存 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/08.%E7%BC%93%E5%AD%98/Redis%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84.html" class="sidebar-item" aria-label="Redis 为什么是单线程的"><!--[--><!--]--> Redis 为什么是单线程的 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/08.%E7%BC%93%E5%AD%98/Redis%20%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6.html" class="sidebar-item" aria-label="Redis 内存淘汰机制"><!--[--><!--]--> Redis 内存淘汰机制 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/08.%E7%BC%93%E5%AD%98/Redis%20%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.html" class="sidebar-item" aria-label="Redis 内部结构"><!--[--><!--]--> Redis 内部结构 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/08.%E7%BC%93%E5%AD%98/Redis%20%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6.html" class="sidebar-item" aria-label="Redis 持久化机制"><!--[--><!--]--> Redis 持久化机制 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/08.%E7%BC%93%E5%AD%98/Redis%20%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B.html" class="sidebar-item" aria-label="Redis 有哪些类型"><!--[--><!--]--> Redis 有哪些类型 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/08.%E7%BC%93%E5%AD%98/Redis%20%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E4%B8%8E%E5%AE%9E%E7%8E%B0.html" class="sidebar-item" aria-label="Redis 集群方案与实现"><!--[--><!--]--> Redis 集群方案与实现 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/08.%E7%BC%93%E5%AD%98/%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E7%9A%84%E5%90%88%E7%90%86%E6%80%A7%E9%97%AE%E9%A2%98.html" class="sidebar-item" aria-label="使用缓存的合理性问题"><!--[--><!--]--> 使用缓存的合理性问题 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/08.%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E5%B4%A9%E6%BA%83.html" class="sidebar-item" aria-label="缓存崩溃"><!--[--><!--]--> 缓存崩溃 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/08.%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7.html" class="sidebar-item" aria-label="缓存降级"><!--[--><!--]--> 缓存降级 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/08.%E7%BC%93%E5%AD%98/%E8%81%8A%E8%81%8A%20Redis%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html" class="sidebar-item" aria-label="聊聊 Redis 使用场景"><!--[--><!--]--> 聊聊 Redis 使用场景 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">消息队列 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/09.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%89%E5%BA%8F%E6%80%A7.html" class="sidebar-item" aria-label="如何保证消息的有序性"><!--[--><!--]--> 如何保证消息的有序性 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/09.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E7%9A%84%E5%A0%86%E7%A7%AF%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF.html" class="sidebar-item" aria-label="消息的堆积解决思路"><!--[--><!--]--> 消息的堆积解决思路 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/09.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF.html" class="sidebar-item" aria-label="消息的幂等性解决思路"><!--[--><!--]--> 消息的幂等性解决思路 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/09.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%8F%91%E8%A1%A5%E5%81%BF%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF.html" class="sidebar-item" aria-label="消息的重发补偿解决思路"><!--[--><!--]--> 消息的重发补偿解决思路 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/09.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html" class="sidebar-item" aria-label="消息队列的使用场景"><!--[--><!--]--> 消息队列的使用场景 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/09.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E8%87%AA%E5%B7%B1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html" class="sidebar-item" aria-label="自己如何实现消息队列"><!--[--><!--]--> 自己如何实现消息队列 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">Netty <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/10.Netty/Netty%20%E5%86%85%E9%83%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.html" class="sidebar-item" aria-label="Netty 内部执行流程"><!--[--><!--]--> Netty 内部执行流程 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/10.Netty/Netty%20%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html" class="sidebar-item" aria-label="Netty 线程模型"><!--[--><!--]--> Netty 线程模型 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/10.Netty/Netty%20%E9%87%8D%E8%BF%9E%E5%AE%9E%E7%8E%B0.html" class="sidebar-item" aria-label="Netty 重连实现"><!--[--><!--]--> Netty 重连实现 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/10.Netty/TCP%20%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html" class="sidebar-item" aria-label="TCP 粘包/拆包的解决办法"><!--[--><!--]--> TCP 粘包/拆包的解决办法 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/10.Netty/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%20Netty.html" class="sidebar-item" aria-label="为什么选择 Netty"><!--[--><!--]--> 为什么选择 Netty <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/10.Netty/%E4%BB%80%E4%B9%88%E6%98%AF%20TCP%20%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85.html" class="sidebar-item" aria-label="什么是 TCP 粘包/拆包"><!--[--><!--]--> 什么是 TCP 粘包/拆包 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/10.Netty/%E5%8E%9F%E7%94%9F%E7%9A%84%20NIO%20%E5%9C%A8%20JDK%201.7%20%E7%89%88%E6%9C%AC%E5%AD%98%E5%9C%A8%20EPoll%20BUG.html" class="sidebar-item" aria-label="原生的 NIO 在 JDK 1.7 版本存在 EPoll BUG"><!--[--><!--]--> 原生的 NIO 在 JDK 1.7 版本存在 EPoll BUG <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/10.Netty/%E8%AF%B4%E8%AF%B4%20Netty%20%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D.html" class="sidebar-item" aria-label="说说 Netty 的零拷贝"><!--[--><!--]--> 说说 Netty 的零拷贝 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/10.Netty/%E8%AF%B4%E8%AF%B4%E4%B8%9A%E5%8A%A1%E4%B8%AD%20Netty%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html" class="sidebar-item" aria-label="说说业务中 Netty 的使用场景"><!--[--><!--]--> 说说业务中 Netty 的使用场景 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">安全篇 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/11.%E5%AE%89%E5%85%A8%E7%AF%87/HTTPS%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.html" class="sidebar-item" aria-label="HTTPS 原理剖析"><!--[--><!--]--> HTTPS 原理剖析 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/11.%E5%AE%89%E5%85%A8%E7%AF%87/HTTPS%20%E9%99%8D%E7%BA%A7%E6%94%BB%E5%87%BB.html" class="sidebar-item" aria-label="HTTPS 降级攻击"><!--[--><!--]--> HTTPS 降级攻击 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/11.%E5%AE%89%E5%85%A8%E7%AF%87/%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6.html" class="sidebar-item" aria-label="基于角色的访问控制"><!--[--><!--]--> 基于角色的访问控制 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/11.%E5%AE%89%E5%85%A8%E7%AF%87/%E5%AE%89%E5%85%A8%E8%A6%81%E7%B4%A0%E4%B8%8E%20STRIDE%20%E5%A8%81%E8%83%81.html" class="sidebar-item" aria-label="安全要素与 STRIDE 威胁"><!--[--><!--]--> 安全要素与 STRIDE 威胁 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/11.%E5%AE%89%E5%85%A8%E7%AF%87/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%AE%A4%E8%AF%81.html" class="sidebar-item" aria-label="授权与认证"><!--[--><!--]--> 授权与认证 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/11.%E5%AE%89%E5%85%A8%E7%AF%87/%E9%98%B2%E8%8C%83%E5%B8%B8%E8%A7%81%E7%9A%84%20Web%20%E6%94%BB%E5%87%BB.html" class="sidebar-item" aria-label="防范常见的 Web 攻击"><!--[--><!--]--> 防范常见的 Web 攻击 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">性能篇 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/12.%E6%80%A7%E8%83%BD%E7%AF%87/%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html" class="sidebar-item" aria-label="如何发现性能瓶颈"><!--[--><!--]--> 如何发现性能瓶颈 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/12.%E6%80%A7%E8%83%BD%E7%AF%87/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E6%9C%89%E5%93%AA%E4%BA%9B.html" class="sidebar-item" aria-label="性能指标有哪些"><!--[--><!--]--> 性能指标有哪些 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/12.%E6%80%A7%E8%83%BD%E7%AF%87/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%9A%84%E5%B8%B8%E8%A7%81%E6%89%8B%E6%AE%B5.html" class="sidebar-item" aria-label="性能调优的常见手段"><!--[--><!--]--> 性能调优的常见手段 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading active">设计模式 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23%20%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5.html" class="sidebar-item" aria-label="23 种设计模式的设计理念"><!--[--><!--]--> 23 种设计模式的设计理念 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%8C%E4%BE%8B%E5%A6%82%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="设计模式之间的异同，例如策略模式与状态模式的区别"><!--[--><!--]--> 设计模式之间的异同，例如策略模式与状态模式的区别 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BB%93%E5%90%88%EF%BC%8C%E4%BE%8B%E5%A6%82%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%20+%20%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E8%B7%B5.html" class="sidebar-item" aria-label="设计模式之间的结合，例如策略模式 + 简单工厂模式的实践"><!--[--><!--]--> 设计模式之间的结合，例如策略模式 + 简单工厂模式的实践 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%8C%E4%BE%8B%E5%A6%82%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%93%AA%E7%A7%8D%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD.html" class="sidebar-item" aria-label="设计模式的性能，例如单例模式哪种性能更好"><!--[--><!--]--> 设计模式的性能，例如单例模式哪种性能更好 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E7%9A%84%E7%90%86%E8%A7%A3.html" class="sidebar-item" aria-label="说说你对设计原则的理解"><!--[--><!--]--> 说说你对设计原则的理解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="说说常用开源框架中设计模式使用分析"><!--[--><!--]--> 说说常用开源框架中设计模式使用分析 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#一、前言" class="router-link-active router-link-exact-active sidebar-item" aria-label="一、前言"><!--[--><!--]--> 一、前言 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#二、责任链设计模式-chain-of-responsibility-pattern" class="router-link-active router-link-exact-active sidebar-item" aria-label="二、责任链设计模式（Chain of Responsibility Pattern）"><!--[--><!--]--> 二、责任链设计模式（Chain of Responsibility Pattern） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#三、工厂模式-factory-pattern" class="router-link-active router-link-exact-active sidebar-item" aria-label="三、工厂模式（Factory Pattern）"><!--[--><!--]--> 三、工厂模式（Factory Pattern） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#四、单例设计模式-singleton-pattern" class="router-link-active router-link-exact-active sidebar-item" aria-label="四、单例设计模式（Singleton Pattern）"><!--[--><!--]--> 四、单例设计模式（Singleton Pattern） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#五、原型设计模式-prototype-pattern" class="router-link-active router-link-exact-active sidebar-item" aria-label="五、原型设计模式（Prototype Pattern）"><!--[--><!--]--> 五、原型设计模式（Prototype Pattern） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#六、策略模式-strategy-pattern" class="router-link-active router-link-exact-active sidebar-item" aria-label="六、策略模式（Strategy Pattern）"><!--[--><!--]--> 六、策略模式（Strategy Pattern） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#七、门面模式-facade-pattern" class="router-link-active router-link-exact-active sidebar-item" aria-label="七、门面模式（Facade Pattern）"><!--[--><!--]--> 七、门面模式（Facade Pattern） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#八、装饰器模式-decorator-pattern" class="router-link-active router-link-exact-active sidebar-item" aria-label="八、装饰器模式（Decorator Pattern）"><!--[--><!--]--> 八、装饰器模式（Decorator Pattern） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#九、适配器模式-adapter-pattern" class="router-link-active router-link-exact-active sidebar-item" aria-label="九、适配器模式（Adapter Pattern）"><!--[--><!--]--> 九、适配器模式（Adapter Pattern） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#十、模板方法模式-template-pattern" class="router-link-active router-link-exact-active sidebar-item" aria-label="十、模板方法模式（Template Pattern）"><!--[--><!--]--> 十、模板方法模式（Template Pattern） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#十一、建造者模式-builder-pattern" class="router-link-active router-link-exact-active sidebar-item" aria-label="十一、建造者模式（Builder Pattern）"><!--[--><!--]--> 十一、建造者模式（Builder Pattern） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#十二、观察者模式-observer-pattern" class="router-link-active router-link-exact-active sidebar-item" aria-label="十二、观察者模式（Observer Pattern）"><!--[--><!--]--> 十二、观察者模式（Observer Pattern） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#十三、命令模式-command-pattern" class="router-link-active router-link-exact-active sidebar-item" aria-label="十三、命令模式（Command Pattern）"><!--[--><!--]--> 十三、命令模式（Command Pattern） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90.html#总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="总结"><!--[--><!--]--> 总结 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">需求分析 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/14.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/%E4%BD%A0%E5%A6%82%E4%BD%95%E5%AF%B9%E9%9C%80%E6%B1%82%E5%8E%9F%E5%9E%8B%E8%BF%9B%E8%A1%8C%E7%90%86%E8%A7%A3%E5%92%8C%E6%8B%86%E5%88%86.html" class="sidebar-item" aria-label="你如何对需求原型进行理解和拆分"><!--[--><!--]--> 你如何对需求原型进行理解和拆分 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/14.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/%E4%BD%A0%E9%92%88%E5%AF%B9%E4%BA%A7%E5%93%81%E6%8F%90%E5%87%BA%E5%93%AA%E4%BA%9B%E4%BA%A4%E4%BA%92%E5%92%8C%E6%94%B9%E8%BF%9B%E6%84%8F%E8%A7%81.html" class="sidebar-item" aria-label="你针对产品提出哪些交互和改进意见"><!--[--><!--]--> 你针对产品提出哪些交互和改进意见 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/14.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82%E7%9A%84%E7%90%86%E8%A7%A3.html" class="sidebar-item" aria-label="说说你对功能性需求的理解"><!--[--><!--]--> 说说你对功能性需求的理解 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/14.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%9D%9E%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82%E7%9A%84%E7%90%86%E8%A7%A3.html" class="sidebar-item" aria-label="说说你对非功能性需求的理解"><!--[--><!--]--> 说说你对非功能性需求的理解 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">设计能力 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/15.%E8%AE%BE%E8%AE%A1%E8%83%BD%E5%8A%9B/%E4%BD%A0%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E9%A2%86%E5%9F%9F%E8%BE%B9%E7%95%8C.html" class="sidebar-item" aria-label="你如何划分领域边界"><!--[--><!--]--> 你如何划分领域边界 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/15.%E8%AE%BE%E8%AE%A1%E8%83%BD%E5%8A%9B/%E4%BD%A0%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E6%9C%8D%E5%8A%A1%E5%8C%96.html" class="sidebar-item" aria-label="你如何考虑服务化"><!--[--><!--]--> 你如何考虑服务化 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/15.%E8%AE%BE%E8%AE%A1%E8%83%BD%E5%8A%9B/%E4%BD%A0%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E7%BB%84%E4%BB%B6%E5%8C%96.html" class="sidebar-item" aria-label="你如何考虑组件化"><!--[--><!--]--> 你如何考虑组件化 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/15.%E8%AE%BE%E8%AE%A1%E8%83%BD%E5%8A%9B/%E4%BD%A0%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1.html" class="sidebar-item" aria-label="你如何进行领域建模"><!--[--><!--]--> 你如何进行领域建模 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/15.%E8%AE%BE%E8%AE%A1%E8%83%BD%E5%8A%9B/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%87%E7%9A%84%20UML%20%E5%9B%BE.html" class="sidebar-item" aria-label="说说你在项目中使用过的 UML 图"><!--[--><!--]--> 说说你在项目中使用过的 UML 图 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/15.%E8%AE%BE%E8%AE%A1%E8%83%BD%E5%8A%9B/%E8%AF%B4%E8%AF%B4%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1.html" class="sidebar-item" aria-label="说说概要设计"><!--[--><!--]--> 说说概要设计 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">未分类 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/16.%E6%9C%AA%E5%88%86%E7%B1%BB/JavaScript%20this%20%E5%85%B3%E9%94%AE%E5%AD%97.html" class="sidebar-item" aria-label="JavaScript this 关键字"><!--[--><!--]--> JavaScript this 关键字 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/16.%E6%9C%AA%E5%88%86%E7%B1%BB/MySQL%20%E4%BC%98%E5%8C%96.html" class="sidebar-item" aria-label="MySQL 优化"><!--[--><!--]--> MySQL 优化 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/16.%E6%9C%AA%E5%88%86%E7%B1%BB/Zookeeper%20%E5%81%87%E6%AD%BB%E8%84%91%E8%A3%82.html" class="sidebar-item" aria-label="Zookeeper 假死脑裂"><!--[--><!--]--> Zookeeper 假死脑裂 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/16.%E6%9C%AA%E5%88%86%E7%B1%BB/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.html" class="sidebar-item" aria-label="双亲委派模型"><!--[--><!--]--> 双亲委派模型 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/16.%E6%9C%AA%E5%88%86%E7%B1%BB/%E6%AD%BB%E4%BF%A1%E3%80%81%E5%BB%B6%E8%BF%9F%E3%80%81%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97.html" class="sidebar-item" aria-label="死信、延迟、重试队列"><!--[--><!--]--> 死信、延迟、重试队列 <!--[--><!--]--></a><!----></li><li><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/16.%E6%9C%AA%E5%88%86%E7%B1%BB/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A1%A5%E5%85%85.html" class="sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="说说常用开源框架中设计模式使用分析" tabindex="-1"><a class="header-anchor" href="#说说常用开源框架中设计模式使用分析" aria-hidden="true">#</a> 说说常用开源框架中设计模式使用分析</h1><h2 id="一、前言" tabindex="-1"><a class="header-anchor" href="#一、前言" aria-hidden="true">#</a> 一、前言</h2><p>设计模式代表了软件设计的最佳实践，是经过不断总结提炼出来的代码设计经验的分类总结，这些模式或者可以简化代码，或者可以是代码逻辑开起来清晰，或者对功能扩展很方便</p><p>设计模式按照使用场景可以分为三大类：</p><ul><li>创建型模式（Creational Patterns）：对对象的实例化过程进行抽象，这使得一个系统可以不用关心这些对象是如何创建，组合，呈现的，对于类创建模式来说通过使用继承改变实例化的类，对于对象创建模式来说通过使用代理来实例化所需要的对象。 <ul><li>工厂模式</li><li>原型模式</li><li>构建者模式</li><li>单例模式</li></ul></li><li>结构型模式（Structural Patterns）：通过对多个类和对象进行组合得到复杂结构的类，一般使用继承继承或者成员变量引用形式来实现。 <ul><li>适配器模式</li><li>桥接模式</li><li>过滤器模式</li><li>组合模式</li><li>装饰者模式</li><li>门面模式</li><li>享元模式</li><li>代理模式</li></ul></li><li>行为型模式（Behavioral Patterns）：行为模式不仅表达了对象和类，还表达了他们之间的交互，涉及到了对象和算法的分配。 <ul><li>责任链模式</li><li>命令模式</li><li>解释器模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>空对象模式</li><li>策略模式</li><li>模板方法模式</li><li>访问者模式</li></ul></li></ul><h2 id="二、责任链设计模式-chain-of-responsibility-pattern" tabindex="-1"><a class="header-anchor" href="#二、责任链设计模式-chain-of-responsibility-pattern" aria-hidden="true">#</a> 二、责任链设计模式（Chain of Responsibility Pattern）</h2><h3 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h3><p>责任链模式是把多个对象串联起来形成一个链状结构，让每个对象都有机会对事件发送者的请求进行处理。责任链模式是设计模式中的行为模式，设计意图是为了使事件发送者和事件接受者之间解耦。通常责任链链中的每个对象都有下一个对象的引入（例如 Tomcat 里面 <code>StandardPipeline</code> 用来管理 <code>valve</code>），或者有个同一个链管理工厂里面使用数组存放了所有的对象（例如 Tomcat 里面 <code>ApplicationFilterChain</code> 用来关系 filter）。</p><h3 id="tomcat-中-valve-链" tabindex="-1"><a class="header-anchor" href="#tomcat-中-valve-链" aria-hidden="true">#</a> Tomcat 中 Valve 链</h3><p>Tomcat 中 <code>StandardEngine</code>, <code>StandardHost</code>, <code>StandardContext</code> 里面都有自己 <code>StandardPipeline</code>,下面以 <code>StandardEngine</code> 里面 <code>StandardPipeline</code> 为例讲解</p><p><img src="/assets/5879294-bf812e77605ba1a3.7dec8152.png" alt="img"></p><p>从上面类图可知道每个 <code>Valve</code> 都要继承 <code>ValveBase</code> 类，该类里面有一个 <code>Valve</code> 的引用，实际是链中下一个节点对象，<code>Valve</code> 就是通过每个 <code>Valve</code> 里面的 <code>next</code> 串联为链的。</p><p><img src="/assets/5879294-51ec28c227c785bd.32971c0f.png" alt="img"></p><p>每个 <code>valve</code> 的 <code>invoke</code> 方法里面调用 <code>next.invoke</code> 激活链中下一个节点,并且 <code>StandardEngine</code>, <code>StandardHost</code>, <code>StandardContext</code> 都有一个 <code>basic valve</code> 这个 <code>valve</code> 在链的末尾用来激活子容器的 <code>valve</code> 链。</p><h3 id="tomcat-中-filter-链" tabindex="-1"><a class="header-anchor" href="#tomcat-中-filter-链" aria-hidden="true">#</a> Tomcat 中 Filter 链</h3><p>Tomcat 中 <code>Filter</code> 链是使用 <code>ApplicationFilterChain</code> 来管理的，具体结构如下图：</p><p><img src="/assets/5879294-a7ecb943aa15c858.603aebbf.png" alt="img"></p><p>可知 <code>Filter</code> 链不是像 <code>Valve</code> 一样在内部维护下个节点的引用，而是在 <code>ApplicationFilterChain</code> 中搞了个数组存放所有的 <code>Filter</code>，并通过 <code>n</code> 统计 <code>Filter</code> 总个数，<code>pos</code> 是当前 <code>filter</code> 的下标。</p><p><code>ApplicationFilterChain</code> 的 <code>doFilter</code> 代码如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>public void doFilter(ServletRequest request, ServletResponse response)
        throws IOException, ServletException {
        ...
        internalDoFilter(request,response);
        ...
    }


private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {

        // Call the next filter if there is one
        if (pos &lt; n) {

            //获取filter链中下标为pos的filter
            ApplicationFilterConfig filterConfig = filters[pos++];
            Filter filter = null;
            try {
                filter = filterConfig.getFilter();
                support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT,
                                          filter, request, response);

                if (request.isAsyncSupported() &amp;&amp; &quot;false&quot;.equalsIgnoreCase(
                        filterConfig.getFilterDef().getAsyncSupported())) {
                    request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,
                            Boolean.FALSE);
                }

                ...

                //调用自定义filter的dofilter方法
                filter.doFilter(request, response, this);


                support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,
                                          filter, request, response);
            } 
            ....

    }
   .....
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h3><ul><li>当一个请求需要根据请求参数的不同由不同对象来处理时候。</li><li>当一个请求需要固定对象顺序处理，并且可扩展性的在固定顺序里面插入新的对象进行处理时候。</li></ul><h2 id="三、工厂模式-factory-pattern" tabindex="-1"><a class="header-anchor" href="#三、工厂模式-factory-pattern" aria-hidden="true">#</a> 三、工厂模式（Factory Pattern）</h2><h3 id="介绍-1" tabindex="-1"><a class="header-anchor" href="#介绍-1" aria-hidden="true">#</a> 介绍</h3><p>工厂模式是创建型模式，他封装了对象的创建过程，调用者使用具体的工厂方法根据参数就可以获取对应的对象。</p><h3 id="spring-框架中-beanfactory" tabindex="-1"><a class="header-anchor" href="#spring-框架中-beanfactory" aria-hidden="true">#</a> Spring 框架中 BeanFactory</h3><p><img src="/assets/5879294-2d102832375148ef.4c7bbb97.png" alt="img"></p><p>如图 <code>BeanFactory</code> 接口提供了 <code>getBean</code> 方法，在 <code>AbstractBeanFactory</code> 中实现了该方法，经过层层继承，实现，最后 <code>DefaultListableBeanFactory</code> 实现了 <code>BeanDefinitionRegistry</code> 接口用来保存 <code>bean</code> 定义，继承了 <code>AbstractAutowireCapableBeanFactory</code> 用来支撑 <code>autowired</code>。</p><h3 id="举个例子" tabindex="-1"><a class="header-anchor" href="#举个例子" aria-hidden="true">#</a> 举个例子</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>@Test
public void testBeanFactoy() throws NamingException, SQLException, ParseException, IOException {

    // 创建 Bean 工厂
    DefaultListableBeanFactory bf = new DefaultListableBeanFactory();

    // 给 Bean 工厂添加 Bean 定义, 解析 xml 里面的 Bean 放入 Bean 工厂
    loadBeanDefinitions(bf);

    // 根据名字从 Bean 工厂获取 Bean
    Hello hello = (Hello) bf.getBean(&quot;hello&quot;);
    hello.sayHello();

    Hello2 hello2 = (Hello2) bf.getBean(&quot;hello2&quot;);
    hello2.sayHello();


}

protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws IOException {
    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

    String[] configLocations = new String[] { &quot;beans2.xml&quot; };
    if (configLocations != null) {
        beanDefinitionReader.loadBeanDefinitions(configLocations);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用场景-1" tabindex="-1"><a class="header-anchor" href="#使用场景-1" aria-hidden="true">#</a> 使用场景</h3><ul><li>不同条件下创建不同实例，用于统一管理 Bean</li><li>不同条件下调用不同工厂方法获取不同场景下的 Bean</li></ul><h2 id="四、单例设计模式-singleton-pattern" tabindex="-1"><a class="header-anchor" href="#四、单例设计模式-singleton-pattern" aria-hidden="true">#</a> 四、单例设计模式（Singleton Pattern）</h2><h3 id="介绍-2" tabindex="-1"><a class="header-anchor" href="#介绍-2" aria-hidden="true">#</a> 介绍</h3><p>单例模式是一种创建型模式，单例模式提供一个创建对象的接口，但是多次调用该接口返回的是同一个实例的引用，目的是为了保证只有一个实例，并且提供一个访问这个实例的统一接口。</p><h3 id="spring-中单例-bean-的创建" tabindex="-1"><a class="header-anchor" href="#spring-中单例-bean-的创建" aria-hidden="true">#</a> Spring 中单例 Bean 的创建</h3><p>Spring 中默认配置的 <code>bean</code> 的 <code>scope</code> 为 <code>singleton</code>，也就是单例作用域。那么看看它是如何做到的。在 <code>AbstractBeanFactory</code> 类里面的 <code>doGetBean</code> 方法：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>protected Object doGetBean(
            final String name, final Class requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException {

    final String beanName = transformedBeanName(name);
    Object bean = null;

    // 解决set循环依赖
    Object sharedInstance = getSingleton(beanName);
    if (sharedInstance != null &amp;&amp; args == null) {
        ...
    }

    else {
        ...
        // 创建单件bean.
        if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, new ObjectFactory() {
                public Object getObject() throws BeansException {
                    try {
                        return createBean(beanName, mbd, args);
                    }
                    catch (BeansException ex) {
                    ...
                        throw ex;
                    }
                }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
        }
       //创建原型bean
        else if (mbd.isPrototype()) {
            ...
        }
        //创建request作用域bean
        else {
            ...
        }
    }
            ...
    return bean;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>getSingleton 代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>public Object getSingleton(String beanName, ObjectFactory singletonFactory) {
    Assert.notNull(beanName, &quot;&#39;beanName&#39; must not be null&quot;);
    synchronized (this.singletonObjects) {
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null) {
            ...
            beforeSingletonCreation(beanName);
            ...
            try {
                singletonObject = singletonFactory.getObject();
            }
            catch (BeanCreationException ex) {
                ...
            }
            finally {
                if (recordSuppressedExceptions) {
                    this.suppressedExceptions = null;
                }
                afterSingletonCreation(beanName);
            }
            addSingleton(beanName, singletonObject);
        }
        return (singletonObject != NULL_OBJECT ? singletonObject : null);
    }
}

protected void addSingleton(String beanName, Object singletonObject) {
    synchronized (this.singletonObjects) {
        this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
        this.singletonFactories.remove(beanName);
        this.earlySingletonObjects.remove(beanName);
        this.registeredSingletons.add(beanName);
    }
}

private final Map singletonObjects = CollectionFactory.createConcurrentMapIfPossible(16);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可知 Spring 内部四通过一个 <code>ConcurrentMap</code> 来管理单件 <code>bean</code> 的。获取 <code>bean</code> 时候会先看看 <code>singletonObjects</code> 中是否有，有则直接返回，没有则创建后放入。</p><p><img src="/assets/5879294-3013e4bf12ef0274.14eec4b5.png" alt="img"></p><p>Spring 的 <code>bean</code> 工厂管理的单例模式管理的是多个 <code>bean</code> 实例的单例，是工厂模式管理所有的 <code>bean</code>,而每个 <code>bean</code> 的创建又使用了单例模式。</p><h3 id="使用场景-2" tabindex="-1"><a class="header-anchor" href="#使用场景-2" aria-hidden="true">#</a> 使用场景</h3><ul><li>同一个 JVM 应用的不同模块需要使用同一个对象实例进行信息共享。</li><li>需要同一个实例来生成全局统一的序列号</li></ul><h2 id="五、原型设计模式-prototype-pattern" tabindex="-1"><a class="header-anchor" href="#五、原型设计模式-prototype-pattern" aria-hidden="true">#</a> 五、原型设计模式（Prototype Pattern）</h2><h3 id="介绍-3" tabindex="-1"><a class="header-anchor" href="#介绍-3" aria-hidden="true">#</a> 介绍</h3><p>相比单例设计模式，原型模式是每次创建一个对象，下面看下 Spring 是如何使用原型模式的</p><h3 id="spring-中原型-bean-的创建" tabindex="-1"><a class="header-anchor" href="#spring-中原型-bean-的创建" aria-hidden="true">#</a> Spring 中原型 bean 的创建</h3><p>创建原型 <code>bean</code> 需要在 <code>xml</code> 特别说明：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;bean id=&quot;hello&quot; class=&quot;com.lusifer.demo.Hello&quot; scope=&quot;prototype&quot;/&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>protected &lt;T&gt; T doGetBean(
        final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)
        throws BeansException {

    final String beanName = transformedBeanName(name);
    Object bean;

    // Eagerly check singleton cache for manually registered singletons.
    Object sharedInstance = getSingleton(beanName);
    if (sharedInstance != null &amp;&amp; args == null) {
     ...
    }

    else {
        ...

        try {
            ...

            // Create bean instance.
            if (mbd.isSingleton()) {
                ...
            }
            //创建原型bean
            else if (mbd.isPrototype()) {
                // It&#39;s a prototype -&gt; create a new instance.
                Object prototypeInstance = null;
                try {
                    beforePrototypeCreation(beanName);
                    prototypeInstance = createBean(beanName, mbd, args);
                }
                finally {
                    afterPrototypeCreation(beanName);
                }
                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
            }

            else {
                ...
            }
        }
        catch (BeansException ex) {
            cleanupAfterBeanCreationFailure(beanName);
            throw ex;
        }
    }
 ...
    return (T) bean;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>createBean</code> 函数里面则是根据 <code>bean</code> 定义创建新 <code>bean</code>，感兴趣的可以看看。</p><h3 id="使用场景-3" tabindex="-1"><a class="header-anchor" href="#使用场景-3" aria-hidden="true">#</a> 使用场景</h3><p>当有业务场景使用某个 <code>bean</code> 时候需要使用自己的一个拷贝的时候使用。</p><h2 id="六、策略模式-strategy-pattern" tabindex="-1"><a class="header-anchor" href="#六、策略模式-strategy-pattern" aria-hidden="true">#</a> 六、策略模式（Strategy Pattern）</h2><h3 id="介绍-4" tabindex="-1"><a class="header-anchor" href="#介绍-4" aria-hidden="true">#</a> 介绍</h3><p>策略模式属于行为性模式，它定义一系列的算法对象,使用时候可以使它们相互替换。</p><h3 id="spring-中-bean-实例化策略" tabindex="-1"><a class="header-anchor" href="#spring-中-bean-实例化策略" aria-hidden="true">#</a> Spring 中 bean 实例化策略</h3><p><img src="/assets/5879294-24f08d52b6fc7fba.b27124ee.png" alt="img"></p><p>从图知道：接口 <code>InstantiationStrategy</code> 是实例化策略接口类，它定义了三个实例化接口，然后 <code>SimpleInstantiationStrategy</code> 实现了该策略，它主要做一些简单的根据构造函数实例号 <code>bean</code> 的工作，然后 <code>CglibSubclassingInstantiationStrategy</code> 又继承了 <code>SimpleInstantiationStrategy</code> 新增了方法注入方式根据 <code>cglib</code> 生成代理类实例化方法。</p><p>在 <code>AbstractAutowireCapableBeanFactory</code> 中管理了该策略的一个对象，默认是 <code>CglibSubclassingInstantiationStrategy</code> 策略，运行时候可以通过 <code>setInstantiationStrategy</code> 改变实例化策略，如果你自己写个个策略的话。</p><h3 id="spring-中-aop-代理策略" tabindex="-1"><a class="header-anchor" href="#spring-中-aop-代理策略" aria-hidden="true">#</a> Spring 中 AOP 代理策略</h3><p><img src="/assets/5879294-7e0b0badc2deef53.9f3d7966.png" alt="img"></p><p>首先看 <code>AopProxyFactory</code> 接口类提供了 <code>createAopProxy</code> 接口，这个是策略模式的接口方法。然后 <code>DefaultAopProxyFactory</code> 实现了该接口作为策略的实现者。然后 <code>ProxyCreatorSupport</code> 里面引用了 <code>AopProxyFactory</code>，并且提供了 <code>get</code>, <code>set</code> 方法用来运行时改变策略，这里 Spring 只实现了 <code>DefaultAopProxyFactory</code> 这一个策略，如果需要自己也可以写个。</p><p><code>DefaultAopProxyFactory</code> 里面的 <code>createAopProxy</code> 的逻辑如下，可以在运行时根据参数决定用 <code>Cglib</code> 策略还是 <code>JDK动态代理</code> 策略生成代理类：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
    // 如果 XML 打开了优化开关，或者设置为了代理目标类，或者目前类没有接口
    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
        Class&lt;?&gt; targetClass = config.getTargetClass();
        if (targetClass == null) {
            throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
                    &quot;Either an interface or a target is required for proxy creation.&quot;);
        }

        // 如果有接口，或者通过 Proxy.newProxyInstance 生成的，则使用 JDK动态代理
        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
            return new JdkDynamicAopProxy(config);
        }

        // 使用 CGLIB
        return new ObjenesisCglibAopProxy(config);
    }
    else {
        // 使用 JDK动态代理
        return new JdkDynamicAopProxy(config);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外 <code>AopProxy</code> 也是一个策略接口类，具体实现的策略为 <code>JdkDynamicAopProxy</code>，<code>CglibAopProxy</code>，<code>ObjenesisCglibAopProxy</code></p><h3 id="tomcat-中-digester-解析-server-xml" tabindex="-1"><a class="header-anchor" href="#tomcat-中-digester-解析-server-xml" aria-hidden="true">#</a> Tomcat 中 Digester 解析 server.xml</h3><p>Tomcat 中的 <code>Digester</code> 是为了解析 <code>server.xml</code> 的，其中每个元素都有一个解析规则就是 <code>Rule</code>，DigestER 一开始先指定不同的解析策略（Rule），然后在具体解析 server.xml 时候根据节点不同使用不同解析策略来解析节点。</p><p><img src="/assets/5879294-2ef6c46b46d18914.657ff555.png" alt="img"></p><p>如图在解析每个节点时候会先找到该节点对应的解析策略，然后循环去调用所有解析策略的方法去处理。</p><h3 id="使用场景-4" tabindex="-1"><a class="header-anchor" href="#使用场景-4" aria-hidden="true">#</a> 使用场景</h3><p>运行时根据条件的不同使用不同的策略处理一个事情，与责任链不同在于，责任链是一个链条，一个事情可以被责任链里面所有节点处理，而 策略模式则是只有有一个对象来处理。</p><h2 id="七、门面模式-facade-pattern" tabindex="-1"><a class="header-anchor" href="#七、门面模式-facade-pattern" aria-hidden="true">#</a> 七、门面模式（Facade Pattern）</h2><h3 id="介绍-5" tabindex="-1"><a class="header-anchor" href="#介绍-5" aria-hidden="true">#</a> 介绍</h3><p>门面模式是一种结构性模式，它通过新增一个门面类对外暴露系统提供的一部分功能，或者屏蔽了内部系统的复杂性，对外部仅仅暴露一个简单的接口，或者通过调用不同的服务对外提供统一的接口，让使用者对这些内部服务透明化。</p><h3 id="模板引擎-velocity-中门面模式使用" tabindex="-1"><a class="header-anchor" href="#模板引擎-velocity-中门面模式使用" aria-hidden="true">#</a> 模板引擎 Velocity 中门面模式使用</h3><p>Velocity 里面的 <code>VelocityEngine</code> 和 <code>Velocity</code> 类都是 <code>RuntimeInstance</code> 类的门面，后者提供了模板渲染的所有功能，前两者则是内部维护 <code>RuntimeInstance</code> 的实例，具体工作还是委托给 <code>RuntimeInstance</code> 来实现。</p><p><img src="/assets/5879294-66c15140bfe5ad36.5486eccd.png" alt="img"></p><p>如图 <code>RuntimeInstance</code> 提供了 <code>Velocity</code> 引擎的所用功能，<code>VelocityEngine</code> 内部直接引用了 <code>RuntimeInstance</code> 的一个实例，<code>VelocityEngine</code> 对外暴露的服务都是委托 <code>RuntimeInstance</code> 实现，并且每次 <code>new</code> 一个 <code>VelocityEngine</code> 内部都会有 <code>RuntimeInstance</code> 的一个实例被创建。而 <code>Velocity</code> 类调用了单例模式类 <code>RuntimeSingleton</code> 里面的方法，<code>RuntimeSingleton</code> 又是 <code>RuntimeInstance</code> 的一个单例模式。</p><h3 id="使用场景-5" tabindex="-1"><a class="header-anchor" href="#使用场景-5" aria-hidden="true">#</a> 使用场景</h3><ul><li>当需要对外屏蔽一个系统的复杂性时候可以考虑使用门面模式对外提供简单可读性高的接口类</li><li>当需要对外部暴露系统一部分权限的接口时候可以考虑使用门面模式减少系统权限。</li><li>当系统需要调用不同服务汇总后在对外提供服务时候可以考虑使用门面模式对外屏蔽细节，之暴露一个接口。</li></ul><h2 id="八、装饰器模式-decorator-pattern" tabindex="-1"><a class="header-anchor" href="#八、装饰器模式-decorator-pattern" aria-hidden="true">#</a> 八、装饰器模式（Decorator Pattern）</h2><h3 id="介绍-6" tabindex="-1"><a class="header-anchor" href="#介绍-6" aria-hidden="true">#</a> 介绍</h3><p>装饰器模式是一种结构性模式，它作用是对对象已有功能进行增强，但是不改变原有对象结构。这避免了通过继承方式进行功能扩充导致的类体系臃肿。</p><h3 id="spring-中-beandefinitiondecorator" tabindex="-1"><a class="header-anchor" href="#spring-中-beandefinitiondecorator" aria-hidden="true">#</a> Spring 中 BeanDefinitionDecorator</h3><p><img src="/assets/5879294-f9a9a083d138e9d0.57b8f27b.png" alt="img"></p><p>如图 <code>ScopedProxyBeanDefinitionDecorator</code> 实现了 <code>decorate</code> 方法用来对 <code>scope</code> 作用域为 <code>request</code> 的 <code>bean</code> 定义进行包装。具体时序图为：</p><p><img src="/assets/5879294-cab488a963d04657.677b6b74.png" alt="img"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class ScopedProxyBeanDefinitionDecorator implements BeanDefinitionDecorator {

    private static final String PROXY_TARGET_CLASS = &quot;proxy-target-class&quot;;


    @Override
    public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {
        boolean proxyTargetClass = true;
        if (node instanceof Element) {
            Element ele = (Element) node;
            if (ele.hasAttribute(PROXY_TARGET_CLASS)) {
                proxyTargetClass = Boolean.valueOf(ele.getAttribute(PROXY_TARGET_CLASS));
            }
        }

        // 创建scoped的代理类，并注册到容器
        BeanDefinitionHolder holder =
                ScopedProxyUtils.createScopedProxy(definition, parserContext.getRegistry(), proxyTargetClass);
        String targetBeanName = ScopedProxyUtils.getTargetBeanName(definition.getBeanName());
        parserContext.getReaderContext().fireComponentRegistered(
                new BeanComponentDefinition(definition.getBeanDefinition(), targetBeanName));
        return holder;
    }

}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于 <code>ScopedProxyBeanDefinitionDecorator</code> 干啥用的呢：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;bean id=&quot;lavaPvgInfo&quot; class=&quot;com.alibaba.lava.privilege.PrivilegeInfo&quot;
    scope=&quot;request&quot;&gt;
    &lt;property name=&quot;aesKey&quot; value=&quot;666&quot; /&gt;
    &lt;aop:scoped-proxy /&gt;
&lt;/bean&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实就是处理 <code>&lt;aop:scoped-proxy /&gt;</code> 的，具体作用是包装 <code>lavaPvgInfo</code> 的 <code>bean</code> 定义为 <code>ScopedProxyFactoryBean</code>，作用是实现 <code>request</code> 作用域 <code>bean</code></p><h3 id="commons-collections-包中-listutils" tabindex="-1"><a class="header-anchor" href="#commons-collections-包中-listutils" aria-hidden="true">#</a> commons-collections 包中 ListUtils</h3><p><img src="/assets/5879294-afa39758e0c2213d.57ddd2e6.png" alt="img"></p><ul><li><code>ListUtils</code> 中的四个方法分别依赖 <code>list</code> 的四种装饰器类对 <code>List</code> 功能进行扩充和限制。</li><li>其中 <code>FixedSizeList</code> 类通过禁止 <code>add/remove</code> 操作保证 <code>list</code> 的大小固定，但是可以修改元素内容</li><li>其中 <code>UnmodifiableList</code> 类通过禁用 <code>add</code>, <code>clear</code>, <code>remove</code>, <code>set</code>,保证 <code>list</code> 的内容不被修改</li><li>其中 <code>SynchronizedList</code> 类通过使用 <code>Lock</code> 来保证 <code>add</code>, <code>set</code>, <code>get</code>, <code>remove</code> 等的同步安全</li><li>其中 <code>LazyList</code> 类则当调用 <code>get</code> 方法发现 <code>list</code> 里面不存在对象时候，自动使用 <code>factory</code> 创建对象.</li></ul><h3 id="使用场景-6" tabindex="-1"><a class="header-anchor" href="#使用场景-6" aria-hidden="true">#</a> 使用场景</h3><p>在不改变原有类结构基础上，新增或者限制或者改造功能时候。</p><h2 id="九、适配器模式-adapter-pattern" tabindex="-1"><a class="header-anchor" href="#九、适配器模式-adapter-pattern" aria-hidden="true">#</a> 九、适配器模式（Adapter Pattern）</h2><h3 id="介绍-7" tabindex="-1"><a class="header-anchor" href="#介绍-7" aria-hidden="true">#</a> 介绍</h3><p>适配器模式属于结构性模式，它为两个不同接口之间互通提供了一种手段。</p><h3 id="spring-中-methodinterceptor-适配器" tabindex="-1"><a class="header-anchor" href="#spring-中-methodinterceptor-适配器" aria-hidden="true">#</a> Spring 中 MethodInterceptor 适配器</h3><p>在 Spring Aop 框架中，<code>MethodInterceptor</code> 接口被用来拦截指定的方法，对方法进行增强。</p><p><img src="/assets/5879294-5eacbfe80fc60237.d017fa9b.png" alt="img"></p><p>大家都知道在 AOP 中每个 <code>advistor</code> 里面会有一个 <code>advice</code> 具体做切面动作，Spring 提供了 <code>AspectJAfterReturningAdvice</code>，<code>AspectJMethodBeforeAdvice</code>，<code>AspectJAroundAdvice</code>，<code>AspectJAfterAdvice</code> 这几个 <code>advice</code>,在 XML 配置 AOP 时候会指定 <code>&lt;aop:after-returning/&gt;</code>, <code>&lt;aop:before/&gt;</code>, <code>&lt;aop:around/&gt;</code>, <code>&lt;aop:after/&gt;</code>, 其实内部就是创建上面对应的这些 <code>advice</code>。</p><p>从图知道 <code>AspectJAfterReturningAdvice</code> 和 <code>AspectJMethodBeforeAdvice</code> 没有实现 <code>MethodInterceptor</code> 接口，其他两者则实现了该接口。而 Spring Aop 的方法拦截器却必须是实现了 <code>MethodInterceptor</code> 的，所以 Spring 提供了对应的适配器来适配这个问题,分别是 <code>MethodBeforeAdviceAdapter</code> 和 <code>AfterReturningAdviceAdapter</code> 和 <code>ThrowsAdviceAdapter</code>。</p><p><img src="/assets/5879294-072d44bda8af7ef9.ae9b6bd9.png" alt="img"></p><p>看下 <code>DefaultAdvisorAdapterRegistry</code> 的 <code>getInterceptors</code> 方法：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {
    List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;MethodInterceptor&gt;(3);

    //从advistor中获取advice
    Advice advice = advisor.getAdvice();

    //如果实现了MethodInterceptor则直接加入，比如AspectJAroundAdvice，AspectJAfterAdvice
    if (advice instanceof MethodInterceptor) {
        interceptors.add((MethodInterceptor) advice);
    }

    //否者看是否有当前advice的适配器，首先检验是否支持，支持则返回对应的适配器
    for (AdvisorAdapter adapter : this.adapters) {
        if (adapter.supportsAdvice(advice)) {
            interceptors.add(adapter.getInterceptor(advisor));
        }
    }
    if (interceptors.isEmpty()) {
        throw new UnknownAdviceTypeException(advisor.getAdvice());
    }
    return interceptors.toArray(new MethodInterceptor[interceptors.size()]);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以 <code>MethodBeforeAdviceAdapter</code> 为例子看下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {

    public boolean supportsAdvice(Advice advice) {
        return (advice instanceof MethodBeforeAdvice);
    }

    public MethodInterceptor getInterceptor(Advisor advisor) {
        MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();
        return new MethodBeforeAdviceInterceptor(advice);
    }

}

public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable {

    private MethodBeforeAdvice advice;


    /**
     * Create a new MethodBeforeAdviceInterceptor for the given advice.
     * @param advice the MethodBeforeAdvice to wrap
     */
    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {
        Assert.notNull(advice, &quot;Advice must not be null&quot;);
        this.advice = advice;
    }

    public Object invoke(MethodInvocation mi) throws Throwable {
        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );
        return mi.proceed();
    }

}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可知 <code>MethodBeforeAdviceInterceptor</code> 继承了 <code>MethodInterceptor</code> 作为了一个适配器内部委托请求给 <code>MethodBeforeAdvice</code>。</p><h3 id="使用场景-7" tabindex="-1"><a class="header-anchor" href="#使用场景-7" aria-hidden="true">#</a> 使用场景</h3><ul><li>两个系统交互时候由于接口参数不一样没办法直接对接，则可以搞个适配器接口做参数转换。</li><li>适配器模式经常是在一个系统或者设计已经定型时候用的，而不是在初始设计时候。一般是因为不影响现在业务情况下，通过适配方式统一接口</li></ul><h2 id="十、模板方法模式-template-pattern" tabindex="-1"><a class="header-anchor" href="#十、模板方法模式-template-pattern" aria-hidden="true">#</a> 十、模板方法模式（Template Pattern）</h2><h3 id="介绍-8" tabindex="-1"><a class="header-anchor" href="#介绍-8" aria-hidden="true">#</a> 介绍</h3><p>模板设计模式是一种行为设计模式，它使用一个抽象类定义了一个模板，这个模板里面定义了一系列的接口，子类则只需要继承该抽象类并且根据需要重写一部分接口。</p><h3 id="ibatis2-中-abstractdaotemplate" tabindex="-1"><a class="header-anchor" href="#ibatis2-中-abstractdaotemplate" aria-hidden="true">#</a> ibatis2 中 AbstractDAOTemplate</h3><p><img src="/assets/5879294-27b737718c1a71bc.8cd6ef81.png" alt="img"></p><p>如图 <code>AbstractDAOTemplate</code> 是抽象模板类，里面定义了 <code>configure</code> 方法，<code>configure</code> 方法里面定义了好多 <code>protected</code> 方法，其中就有些是抽象方法。类 <code>SpringDAOTemplate</code>，<code>IbatisDAOTemplate</code>，<code>GenericCIDAOTemplate</code>，<code>GenericSIDAOTemplate</code> 则继承了 <code>AbstractDAOTemplate</code> 类并重写了一部分方法。</p><h3 id="tomcat-中-digester-里面的-rule" tabindex="-1"><a class="header-anchor" href="#tomcat-中-digester-里面的-rule" aria-hidden="true">#</a> Tomcat 中 Digester 里面的 Rule</h3><p>Tomcat 中的 <code>Digester</code> 是为了解析 <code>server.xml</code> 的，其中每个元素都有一个解析规则就是 <code>Rule</code> ,类图如下：</p><p><img src="/assets/5879294-d5e4f335d709ab29.ec629760.png" alt="img"></p><p>如图：Rule 是抽象类，对于每个解析的节点来说 Rule 提供了解析所需所有的方法，而他的子类则根据自己的特殊性重写一部分方法来支持自己的特性。</p><h3 id="tomcat-中-endpoint" tabindex="-1"><a class="header-anchor" href="#tomcat-中-endpoint" aria-hidden="true">#</a> Tomcat 中 Endpoint</h3><p><img src="/assets/5879294-bd4bb3f72e7da976.da29e351.png" alt="img"></p><p>如图 <code>AbstractEndpoint</code> 是个抽象类，定义了 <code>Endpoint</code> 的所有接口，然后 <code>JIoEndpoint</code> 继承了该类并且重写了一部分重要的方法实现了 <code>BIO</code> 方式 <code>endpoint</code> , <code>NioEndpoint</code> 则重写了方法实现了 <code>NIO</code> 的 <code>endpoint</code>.</p><h3 id="使用场景-8" tabindex="-1"><a class="header-anchor" href="#使用场景-8" aria-hidden="true">#</a> 使用场景</h3><p>当多个子类具有共同的操作流程逻辑，并且其中某些流程节点操作需要自己定制化时候。</p><h2 id="十一、建造者模式-builder-pattern" tabindex="-1"><a class="header-anchor" href="#十一、建造者模式-builder-pattern" aria-hidden="true">#</a> 十一、建造者模式（Builder Pattern）</h2><h3 id="介绍-9" tabindex="-1"><a class="header-anchor" href="#介绍-9" aria-hidden="true">#</a> 介绍</h3><p>建造者模式是一种创建型模式，将一个复制对象的创建屏蔽到接口内部，用户使用时候只需要传递固定的参数，内部就会执行复杂逻辑后返回会用户需要的对象，用户不需要知道创建的细节。</p><h3 id="mybatis-中的-sqlsessionfactorybuilder" tabindex="-1"><a class="header-anchor" href="#mybatis-中的-sqlsessionfactorybuilder" aria-hidden="true">#</a> Mybatis 中的 SqlSessionFactoryBuilder</h3><p><img src="/assets/5879294-96342ae1a578c8c6.23880864.png" alt="img"></p><p>如图 MyBaits 中的 <code>SqlSessionFactoryBuilder</code> 就是典型的创建者模式，他内部有多个 <code>build</code> 方法，根据参数的不同创建出 <code>SqlSessionFactory</code> 对象，使用者只需要传递具体参数而不用关系内部是如何创建出需要的对象的。<code>SqlSessionFactoryBean</code> 大家应该很熟悉，在 xml 里面配置的。</p><h3 id="使用场景-9" tabindex="-1"><a class="header-anchor" href="#使用场景-9" aria-hidden="true">#</a> 使用场景</h3><p>当一个对象比较复杂并且容易出错时候，可以考虑这种模式去屏蔽创造细节。</p><h2 id="十二、观察者模式-observer-pattern" tabindex="-1"><a class="header-anchor" href="#十二、观察者模式-observer-pattern" aria-hidden="true">#</a> 十二、观察者模式（Observer Pattern）</h2><h3 id="介绍-10" tabindex="-1"><a class="header-anchor" href="#介绍-10" aria-hidden="true">#</a> 介绍</h3><p>观察者模式是一种行为模式，它定义了当一个对象的状态或者属性发生变化时候，通通知其他对这些状态感兴趣的对象。观察者模式也叫发布-订阅模式，就是说当你订阅了摸一个主体时候，如果发布者改变了主题内容，那么所有订阅这个主体者都会受到通知。</p><h3 id="spring-中-applicationlistener" tabindex="-1"><a class="header-anchor" href="#spring-中-applicationlistener" aria-hidden="true">#</a> Spring 中 ApplicationListener</h3><p><img src="/assets/5879294-eee8a0c0437a83d5.1560560a.png" alt="img"></p><p>如图 黄色部分的 <code>listener</code> 们可以认为是订阅者，红色的 <code>context</code> 是发布者，<code>context</code> 在 <code>IOC</code> 不同状态会给这些订阅者发布不同的消息通知订阅者容器状态。蓝色的为具体的事件（这里为容器不同状态），其中 <code>ContextRefreshedEvent</code> 是 <code>IOC</code> 刷新完成（也就是 <code>bean</code> 解析完成，创建完毕并且 <code>autowired</code> 完成）后的事件这个经常用。 。这里 <code>context</code> 并不是直接来管理黄色的 <code>listener</code> 订阅者的，而是委托给了绿色的部分，该部分是可以增加删除订阅者，并且发布事件给订阅者。</p><p>其实 Tomcat 中的 <code>Lifecycle</code> 也是这种机制</p><h3 id="使用场景-10" tabindex="-1"><a class="header-anchor" href="#使用场景-10" aria-hidden="true">#</a> 使用场景</h3><p>满足发布-订阅条件的，当一个对象状态或者属性变化，需要把这种变化通知到订阅者时候。</p><h2 id="十三、命令模式-command-pattern" tabindex="-1"><a class="header-anchor" href="#十三、命令模式-command-pattern" aria-hidden="true">#</a> 十三、命令模式（Command Pattern）</h2><h3 id="介绍-11" tabindex="-1"><a class="header-anchor" href="#介绍-11" aria-hidden="true">#</a> 介绍</h3><p>命令模式是一种行为模式，通过把命令封装为一个对象，命令发送者把命令对象发出后，就不去管是谁来接受处理这个命令，命令接受者接受到命令对象后进行处理，也不用管命令是谁发出的，所以命令模式实现了发送者与接受者之间的解耦，而具体把命令发送给谁还需要一个控制器。</p><h3 id="tomcat-中命令模式" tabindex="-1"><a class="header-anchor" href="#tomcat-中命令模式" aria-hidden="true">#</a> Tomcat 中命令模式</h3><p>Tomcat 作为一个服务器本身会接受外部大量请求，当一个请求过来后 Tomcat 根据域名去找对应的 host,找到 host 后会根据应用名去找具体的 context(应用)，然后具体应用处理请求。对于具体 host 来说他不关心这个请求是谁给的，对应请求来说他不必关心谁来处理，但是两者是通过 request 封装请求对象进行关联起来。</p><p><img src="/assets/5879294-f9e90281b20fe688.25021170.png" alt="img"></p><p>Tomcat 中 <code>Connector</code> 作为命令发出者，<code>Connector</code> 接受到请求后把请求内容封装为 <code>request</code> 对象（命令对象），然后使用 <code>CoyoteAdapter</code> 作为分发器把请求具体发配到具体的 <code>host</code>, <code>host</code> 在根据 <code>request</code> 对象找到具体的 <code>context</code>,至此找到了具体的应用，交给具体应用处理。</p><p>另外对于使用 SpringMVC 的应用来说，上面找到具体应用，但是具体交给那个 controller 来处理那，这是不是也是命令模式的使用那。</p><h3 id="使用场景-11" tabindex="-1"><a class="header-anchor" href="#使用场景-11" aria-hidden="true">#</a> 使用场景</h3><p>当事件发送者和接受者直接需要完全解耦（直接并不存在引用关系）时候。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>设计模式中每一个模式都描述了在我们工作中不断重复发生的问题，以及问题的解决方案，所以真正掌握设计模式可以避免我们做不必要的重复劳动。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E7%9A%84%E7%90%86%E8%A7%A3.html" class="" aria-label="说说你对设计原则的理解"><!--[--><!--]--> 说说你对设计原则的理解 <!--[--><!--]--></a></span><!----></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.f0c02a19.js" defer></script>
  </body>
</html>
